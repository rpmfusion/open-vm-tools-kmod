diff -w -N -r -u open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/COPYING open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/COPYING
--- open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/COPYING	1970-01-01 01:00:00.000000000 +0100
+++ open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/COPYING	2009-12-17 22:26:31.000000000 +0100
@@ -0,0 +1,339 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff -w -N -r -u open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/Makefile open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/Makefile
--- open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/Makefile	2009-12-17 22:26:31.000000000 +0100
@@ -0,0 +1,167 @@
+#!/usr/bin/make -f
+##########################################################
+# Copyright (C) 1998 VMware, Inc. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation version 2 and no later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+#
+##########################################################
+
+####
+####  VMware kernel module Makefile to be distributed externally
+####
+
+####
+#### SRCROOT _must_ be a relative path.
+####
+SRCROOT = .
+
+#
+# open-vm-tools doesn't replicate shared source files for different modules;
+# instead, files are kept in shared locations. So define a few useful macros
+# to be able to handle both cases cleanly.
+#
+INCLUDE      :=
+ifdef OVT_SOURCE_DIR
+AUTOCONF_DIR := $(OVT_SOURCE_DIR)/modules/linux/shared/autoconf
+VMLIB_PATH   = $(OVT_SOURCE_DIR)/lib/$(1)
+INCLUDE      += -I$(OVT_SOURCE_DIR)/modules/linux/shared
+INCLUDE      += -I$(OVT_SOURCE_DIR)/lib/include
+else
+AUTOCONF_DIR := $(SRCROOT)/shared/autoconf
+INCLUDE      += -I$(SRCROOT)/shared
+endif
+
+
+VM_UNAME = $(shell uname -r)
+
+# Header directory for the running kernel
+HEADER_DIR = /lib/modules/$(VM_UNAME)/build/include
+
+BUILD_DIR = $(HEADER_DIR)/..
+
+DRIVER := vmxnet3
+PRODUCT := tools-source
+
+# Grep program
+GREP = /bin/grep
+
+vm_check_gcc = $(shell if $(CC) $(1) -S -o /dev/null -xc /dev/null \
+        > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi)
+vm_check_file = $(shell if test -f $(1); then echo "yes"; else echo "no"; fi)
+
+ifndef VM_KBUILD
+VM_KBUILD := no
+ifeq ($(call vm_check_file,$(BUILD_DIR)/Makefile), yes)
+ifneq ($(call vm_check_file,$(BUILD_DIR)/Rules.make), yes)
+VM_KBUILD := 26
+endif
+endif
+export VM_KBUILD
+endif
+
+ifndef VM_KBUILD_SHOWN
+ifeq ($(VM_KBUILD), no)
+VM_DUMMY := $(shell echo >&2 "Using standalone build system.")
+else
+ifeq ($(VM_KBUILD), 24)
+VM_DUMMY := $(shell echo >&2 "Using 2.4.x kernel build system.")
+else
+VM_DUMMY := $(shell echo >&2 "Using 2.6.x kernel build system.")
+endif
+endif
+VM_KBUILD_SHOWN := yes
+export VM_KBUILD_SHOWN
+endif
+
+ifneq ($(VM_KBUILD), no)
+
+VMCCVER := $(shell $(CC) -dumpversion)
+
+# If there is no version defined, we are in toplevel pass, not yet in kernel makefiles...
+ifeq ($(VERSION),)
+
+ifeq ($(VM_KBUILD), 24)
+DRIVER_KO := $(DRIVER).o
+else
+DRIVER_KO := $(DRIVER).ko
+endif
+
+.PHONY: $(DRIVER_KO)
+
+auto-build: $(DRIVER_KO)
+	cp -f $< $(SRCROOT)/../$(DRIVER).o
+
+# $(DRIVER_KO) is a phony target, so compare file times explicitly
+$(DRIVER): $(DRIVER_KO)
+	if [ $< -nt $@ ] || [ ! -e $@ ] ; then cp -f $< $@; fi
+
+# Pass gcc version down the chain, so we can detect if kernel attempts to use unapproved compiler
+VM_CCVER := $(VMCCVER)
+export VM_CCVER
+VM_CC := $(CC)
+export VM_CC
+
+MAKEOVERRIDES := $(filter-out CC=%,$(MAKEOVERRIDES))
+
+#
+# Define a setup target that gets built before the actual driver.
+# This target may not be used at all, but if it is then it will be defined
+# in Makefile.kernel
+#
+prebuild:: ;
+postbuild:: ;
+
+$(DRIVER_KO): prebuild
+	make -C $(BUILD_DIR) SUBDIRS=$$PWD SRCROOT=$$PWD/$(SRCROOT) \
+	  MODULEBUILDDIR=$(MODULEBUILDDIR) modules
+	make -C $$PWD SRCROOT=$$PWD/$(SRCROOT) \
+	  MODULEBUILDDIR=$(MODULEBUILDDIR) postbuild
+endif
+
+vm_check_build = $(shell if $(CC) $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) \
+	$(CPPFLAGS) $(CFLAGS) $(CFLAGS_KERNEL) $(LINUXINCLUDE) \
+	$(EXTRA_CFLAGS) -Iinclude2/asm/mach-default \
+	-DKBUILD_BASENAME=\"$(DRIVER)\" \
+	-Werror -S -o /dev/null -xc $(1) \
+	> /dev/null 2>&1; then echo "$(2)"; else echo "$(3)"; fi)
+
+CC_WARNINGS := -Wall -Wstrict-prototypes
+CC_OPTS := $(GLOBAL_DEFS) $(CC_WARNINGS) -DVMW_USING_KBUILD
+ifdef VMX86_DEVEL
+CC_OPTS += -DVMX86_DEVEL
+endif
+ifdef VMX86_DEBUG
+CC_OPTS += -DVMX86_DEBUG
+endif
+
+include $(SRCROOT)/Makefile.kernel
+
+ifdef TOPDIR
+ifeq ($(VM_KBUILD), 24)
+
+O_TARGET := $(DRIVER).o
+
+obj-y := $($(DRIVER)-y)
+
+include $(TOPDIR)/Rules.make
+endif
+endif
+
+else
+
+include $(SRCROOT)/Makefile.normal
+
+endif
+
+#.SILENT:
diff -w -N -r -u open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/Makefile.kernel open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/Makefile.kernel
--- open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/Makefile.kernel	1970-01-01 01:00:00.000000000 +0100
+++ open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/Makefile.kernel	2009-12-17 22:26:31.000000000 +0100
@@ -0,0 +1,42 @@
+#!/usr/bin/make -f
+##########################################################
+# Copyright (C) 2008 VMware, Inc. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation version 2 and no later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+#
+##########################################################
+
+####
+####  VMware vmxnet3 Makefile to be distributed externally
+####
+
+INCLUDE += -I.
+
+ifdef OVT_SOURCE_DIR
+INCLUDE += -I$(OVT_SOURCE_DIR)/modules/shared/vmxnet
+endif
+
+EXTRA_CFLAGS := $(CC_OPTS) $(INCLUDE)
+
+EXTRA_CFLAGS += $(call vm_check_build, $(AUTOCONF_DIR)/skblin.c, -DVMW_SKB_LINEARIZE_2618, )
+EXTRA_CFLAGS += $(call vm_check_build, $(AUTOCONF_DIR)/netif_num_params.c, , -DVMW_NETIF_SINGLE_NAPI_PARM)
+
+obj-m += $(DRIVER).o
+
+$(DRIVER)-y := $(subst $(SRCROOT)/, , $(patsubst %.c, %.o, $(wildcard $(SRCROOT)/*.c)))
+
+clean:
+	rm -rf $(wildcard $(DRIVER).mod.c $(DRIVER).ko .tmp_versions \
+	       Module.symvers Modules.symvers Module.markers modules.order \
+	       $(foreach dir,./,$(addprefix $(dir),.*.cmd .*.o.flags *.o)))
diff -w -N -r -u open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/README open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/README
--- open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/README	1970-01-01 01:00:00.000000000 +0100
+++ open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/README	2009-12-17 22:26:31.000000000 +0100
@@ -0,0 +1,11 @@
+The files in this directory are the source files for the VMware
+3rd Generation Virtual Ethernet Adapter driver.  In order to build, 
+make certain the Makefile is correct, especially about whether or 
+not your system is multi-processor or not, and then just type:
+
+	make
+
+from this directory.  A copy of the module will be left in 'vmxnet3.o',
+which can then be installed in /lib/modules/<kernel-name>/net.
+
+If you have any problems or questions, send mail to support@vmware.com
diff -w -N -r -u open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/vmxnet3_drv.c open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/vmxnet3_drv.c
--- open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/vmxnet3_drv.c	1970-01-01 01:00:00.000000000 +0100
+++ open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/vmxnet3_drv.c	2009-12-17 23:49:58.000000000 +0100
@@ -0,0 +1,3210 @@
+/*********************************************************
+ * Copyright (C) 2007 VMware, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation version 2 and no later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ *
+ *********************************************************/
+
+#include "driver-config.h"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+#error "vmxnet3 driver is not supported on kernels earlier than 2.6"
+#endif
+
+#include "vm_device_version.h"
+
+#include "vmxnet3_int.h"
+#include "vmxnet3_shm.h"
+
+char vmxnet3_driver_name[] = "vmxnet3";
+#define VMXNET3_DRIVER_DESC "VMware vmxnet3 virtual NIC driver"
+
+static const struct pci_device_id vmxnet3_pciid_table[] = {
+	{PCI_DEVICE(PCI_VENDOR_ID_VMWARE, PCI_DEVICE_ID_VMWARE_VMXNET3)},
+	{0}
+};
+
+MODULE_DEVICE_TABLE(pci, vmxnet3_pciid_table);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+static int disable_lro;
+#endif
+
+static atomic_t devices_found;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+static unsigned int num_enable_shm;
+#endif
+#define VMXNET3_SHM_MAX_DEVICES 10
+static int enable_shm[VMXNET3_SHM_MAX_DEVICES + 1] =
+{ [0 ... VMXNET3_SHM_MAX_DEVICES] = -1 };
+static char *shm_disclaimer = NULL;
+static int correct_shm_disclaimer;
+static int shm_pool_size = SHM_DEFAULT_DATA_SIZE;
+#define VMXNET3_SHM_DISCLAIMER "IReallyWantThisModeIAmAVMwarePartner"
+
+/*
+ *    Enable/Disable the given intr
+ */
+
+static inline void
+vmxnet3_enable_intr(struct vmxnet3_adapter *adapter, unsigned intr_idx)
+{
+	VMXNET3_WRITE_BAR0_REG(adapter, VMXNET3_REG_IMR + intr_idx * 8, 0);
+}
+
+
+static inline void
+vmxnet3_disable_intr(struct vmxnet3_adapter *adapter, unsigned intr_idx)
+{
+	VMXNET3_WRITE_BAR0_REG(adapter, VMXNET3_REG_IMR + intr_idx * 8, 1);
+}
+
+
+/*
+ *    Enable/Disable all intrs used by the device
+ */
+
+static void
+vmxnet3_enable_all_intrs(struct vmxnet3_adapter *adapter)
+{
+	int i;
+
+	for (i = 0; i < adapter->intr.num_intrs; i++)
+		vmxnet3_enable_intr(adapter, i);
+}
+
+
+static void
+vmxnet3_disable_all_intrs(struct vmxnet3_adapter *adapter)
+{
+	int i;
+
+	for (i = 0; i < adapter->intr.num_intrs; i++)
+		vmxnet3_disable_intr(adapter, i);
+}
+
+
+static INLINE void
+vmxnet3_ack_events(struct vmxnet3_adapter *adapter, u32 events)
+{
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_ECR, events);
+}
+
+
+static inline Bool
+vmxnet3_tq_stopped(struct vmxnet3_tx_queue *tq, struct vmxnet3_adapter *adapter)
+{
+	return compat_netif_queue_stopped(adapter->netdev);
+}
+
+
+/*
+ *
+ * Request the stack to start/stop/wake the tq. This only deals with the OS
+ * side, it does NOT handle the device side
+ */
+static inline void
+vmxnet3_tq_start(struct vmxnet3_tx_queue *tq, struct vmxnet3_adapter  *adapter)
+{
+	tq->stopped = FALSE;
+	compat_netif_start_queue(adapter->netdev);
+}
+
+
+static inline void
+vmxnet3_tq_wake(struct vmxnet3_tx_queue *tq, struct vmxnet3_adapter  *adapter)
+{
+	tq->stopped = FALSE;
+	compat_netif_wake_queue(adapter->netdev);
+}
+
+
+static inline void
+vmxnet3_tq_stop(struct vmxnet3_tx_queue *tq, struct vmxnet3_adapter  *adapter)
+{
+	tq->stopped = TRUE;
+	tq->num_stop++;
+	compat_netif_stop_queue(adapter->netdev);
+}
+
+
+/*
+ * This may start or stop the tx queue.
+ */
+
+static void
+vmxnet3_check_link(struct vmxnet3_adapter *adapter)
+{
+	u32 ret;
+
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD, VMXNET3_CMD_GET_LINK);
+	ret = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);
+	adapter->link_speed = ret >> 16;
+	if (ret & 1) { /* Link is up. */
+		printk(KERN_INFO "%s: NIC Link is Up %d Mbps\n",
+		       adapter->netdev->name, adapter->link_speed);
+		if (!netif_carrier_ok(adapter->netdev))
+			netif_carrier_on(adapter->netdev);
+
+		vmxnet3_tq_start(&adapter->tx_queue, adapter);
+	} else {
+		printk(KERN_INFO "%s: NIC Link is Down\n",
+		       adapter->netdev->name);
+		if (netif_carrier_ok(adapter->netdev))
+			netif_carrier_off(adapter->netdev);
+
+		vmxnet3_tq_stop(&adapter->tx_queue, adapter);
+	}
+}
+
+
+/*
+ * process events indicated in ECR
+ */
+
+static void
+vmxnet3_process_events(struct vmxnet3_adapter *adapter)
+{
+	u32 events = le32_to_cpu(adapter->shared->ecr);
+	if (!events)
+		return;
+
+	vmxnet3_ack_events(adapter, events);
+
+	/* Check if link state has changed */
+	if (events & VMXNET3_ECR_LINK)
+		vmxnet3_check_link(adapter);
+
+	/* Check if there is an error on xmit/recv queues */
+	if (events & (VMXNET3_ECR_TQERR | VMXNET3_ECR_RQERR)) {
+		VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,
+				       VMXNET3_CMD_GET_QUEUE_STATUS);
+
+		if (adapter->tqd_start->status.stopped) {
+			printk(KERN_ERR "%s: tq error 0x%x\n",
+			       adapter->netdev->name,
+			       le32_to_cpu(adapter->tqd_start->status.error));
+		}
+		if (adapter->rqd_start->status.stopped) {
+			printk(KERN_ERR "%s: rq error 0x%x\n",
+			       adapter->netdev->name,
+			       adapter->rqd_start->status.error);
+		}
+
+		compat_schedule_work(&adapter->work);
+	}
+}
+
+#ifdef __BIG_ENDIAN_BITFIELD
+/*
+ * The device expects the bitfields in shared structures to be written in
+ * little endian. When CPU is big endian, the following routines are used to
+ * correctly read and write into ABI.
+ * The general technique used here is : double word bitfields are defined in
+ * opposite order for big endian architecture. Then before reading them in
+ * driver the complete double word is translated using le32_to_cpu. Similarly
+ * After the driver writes into bitfields, cpu_to_le32 is used to translate the
+ * double words into required format.
+ * In order to avoid touching bits in shared structure more than once, temporary
+ * descriptors are used. These are passed as srcDesc to following functions.
+ */
+static void vmxnet3_RxDescToCPU(const struct Vmxnet3_RxDesc *srcDesc,
+				struct Vmxnet3_RxDesc *dstDesc)
+{
+	u32 *src = (u32 *)srcDesc + 2;
+	u32 *dst = (u32 *)dstDesc + 2;
+	dstDesc->addr = le64_to_cpu(srcDesc->addr);
+	*dst = le32_to_cpu(*src);
+	dstDesc->ext1 = le32_to_cpu(srcDesc->ext1);
+}
+
+static void vmxnet3_TxDescToLe(const struct Vmxnet3_TxDesc *srcDesc,
+			       struct Vmxnet3_TxDesc *dstDesc)
+{
+	int i;
+	u32 *src = (u32 *)(srcDesc + 1);
+	u32 *dst = (u32 *)(dstDesc + 1);
+
+	/* Working backwards so that the gen bit is set at the end. */
+	for (i = 2; i > 0; i--) {
+		src--;
+		dst--;
+		*dst = cpu_to_le32(*src);
+	}
+}
+
+
+static void vmxnet3_RxCompToCPU(const struct Vmxnet3_RxCompDesc *srcDesc,
+				struct Vmxnet3_RxCompDesc *dstDesc)
+{
+	int i = 0;
+	u32 *src = (u32 *)srcDesc;
+	u32 *dst = (u32 *)dstDesc;
+	for (i = 0; i < sizeof(struct Vmxnet3_RxCompDesc) / sizeof(u32); i++) {
+		*dst = le32_to_cpu(*src);
+		src++;
+		dst++;
+	}
+}
+
+
+/* Used to read bitfield values from double words. */
+static u32 get_bitfield32(const __le32 *bitfield, u32 pos, u32 size)
+{
+	u32 temp = le32_to_cpu(*bitfield);
+	u32 mask = ((1 << size) - 1) << pos;
+	temp &= mask;
+	temp >>= pos;
+	return temp;
+}
+
+
+
+#endif  /* __BIG_ENDIAN_BITFIELD */
+
+#ifdef __BIG_ENDIAN_BITFIELD
+
+#   define VMXNET3_TXDESC_GET_GEN(txdesc) get_bitfield32(((const __le32 *) \
+			txdesc) + VMXNET3_TXD_GEN_DWORD_SHIFT, \
+			VMXNET3_TXD_GEN_SHIFT, VMXNET3_TXD_GEN_SIZE)
+#   define VMXNET3_TXDESC_GET_EOP(txdesc) get_bitfield32(((const __le32 *) \
+			txdesc) + VMXNET3_TXD_EOP_DWORD_SHIFT, \
+			VMXNET3_TXD_EOP_SHIFT, VMXNET3_TXD_EOP_SIZE)
+#   define VMXNET3_TCD_GET_GEN(tcd) get_bitfield32(((const __le32 *)tcd) + \
+			VMXNET3_TCD_GEN_DWORD_SHIFT, VMXNET3_TCD_GEN_SHIFT, \
+			VMXNET3_TCD_GEN_SIZE)
+#   define VMXNET3_TCD_GET_TXIDX(tcd) get_bitfield32((const __le32 *)tcd, \
+			VMXNET3_TCD_TXIDX_SHIFT, VMXNET3_TCD_TXIDX_SIZE)
+#   define vmxnet3_getRxComp(dstrcd, rcd, tmp) do { \
+			(dstrcd) = (tmp); \
+			vmxnet3_RxCompToCPU((rcd), (tmp)); \
+		} while (0)
+#   define vmxnet3_getRxDesc(dstrxd, rxd, tmp) do { \
+			(dstrxd) = (tmp); \
+			vmxnet3_RxDescToCPU((rxd), (tmp)); \
+		} while (0)
+
+#else
+
+#   define VMXNET3_TXDESC_GET_GEN(txdesc) ((txdesc)->gen)
+#   define VMXNET3_TXDESC_GET_EOP(txdesc) ((txdesc)->eop)
+#   define VMXNET3_TCD_GET_GEN(tcd) ((tcd)->gen)
+#   define VMXNET3_TCD_GET_TXIDX(tcd) ((tcd)->txdIdx)
+#   define vmxnet3_getRxComp(dstrcd, rcd, tmp) (dstrcd) = (rcd)
+#   define vmxnet3_getRxDesc(dstrxd, rxd, tmp) (dstrxd) = (rxd)
+
+#endif /* __BIG_ENDIAN_BITFIELD  */
+
+
+static void
+vmxnet3_unmap_tx_buf(struct vmxnet3_tx_buf_info *tbi,
+		     struct pci_dev *pdev)
+{
+	if (tbi->map_type == VMXNET3_MAP_SINGLE)
+		pci_unmap_single(pdev, tbi->dma_addr, tbi->len,
+				 PCI_DMA_TODEVICE);
+	else if (tbi->map_type == VMXNET3_MAP_PAGE)
+		pci_unmap_page(pdev, tbi->dma_addr, tbi->len,
+			       PCI_DMA_TODEVICE);
+	else
+		BUG_ON(tbi->map_type != VMXNET3_MAP_NONE);
+
+	tbi->map_type = VMXNET3_MAP_NONE; /* to help debugging */
+}
+
+
+/*
+ *    Returns # of tx descs that this pkt used
+ *
+ * Side-effects:
+ *    1. mappings are freed
+ *    2. buf_info[] are updated
+ *    3. tx_ring.{avail, next2comp} are updated.
+ */
+
+static int
+vmxnet3_unmap_pkt(u32 eop_idx, struct vmxnet3_tx_queue *tq,
+		  struct pci_dev *pdev,	struct vmxnet3_adapter *adapter)
+{
+	struct sk_buff *skb;
+	int entries = 0;
+
+	/* no out of order completion */
+	BUG_ON(tq->buf_info[eop_idx].sop_idx != tq->tx_ring.next2comp);
+	BUG_ON(VMXNET3_TXDESC_GET_EOP(&(tq->tx_ring.base[eop_idx].txd)) != 1);
+
+	dev_dbg(&adapter->pdev->dev, "tx complete [%u %u]\n",
+		tq->tx_ring.next2comp, eop_idx);
+	skb = tq->buf_info[eop_idx].skb;
+	BUG_ON(skb == NULL);
+	tq->buf_info[eop_idx].skb = NULL;
+
+	VMXNET3_INC_RING_IDX_ONLY(eop_idx, tq->tx_ring.size);
+
+	while (tq->tx_ring.next2comp != eop_idx) {
+		vmxnet3_unmap_tx_buf(tq->buf_info + tq->tx_ring.next2comp,
+				     pdev);
+
+		/* update next2comp w/o tx_lock. Since we are marking more,
+		 * instead of less, tx ring entries avail, the worst case is
+		 * that the tx routine incorrectly re-queues a pkt due to
+		 * insufficient tx ring entries.
+		 */
+		vmxnet3_cmd_ring_adv_next2comp(&tq->tx_ring);
+		entries++;
+	}
+
+	vmxnet3_dev_kfree_skb_any(adapter, skb);
+	return entries;
+}
+
+
+static int
+vmxnet3_tq_tx_complete(struct vmxnet3_tx_queue *tq,
+		       struct vmxnet3_adapter *adapter)
+{
+	int completed = 0;
+	union Vmxnet3_GenericDesc *gdesc;
+
+	gdesc = tq->comp_ring.base + tq->comp_ring.next2proc;
+	while (VMXNET3_TCD_GET_GEN(&gdesc->tcd) == tq->comp_ring.gen) {
+		completed += vmxnet3_unmap_pkt(VMXNET3_TCD_GET_TXIDX(
+					       &gdesc->tcd), tq, adapter->pdev,
+					       adapter);
+
+		vmxnet3_comp_ring_adv_next2proc(&tq->comp_ring);
+		gdesc = tq->comp_ring.base + tq->comp_ring.next2proc;
+	}
+
+	if (completed) {
+		spin_lock(&tq->tx_lock);
+		if (unlikely(vmxnet3_tq_stopped(tq, adapter) &&
+			     vmxnet3_cmd_ring_desc_avail(&tq->tx_ring) >
+			     VMXNET3_WAKE_QUEUE_THRESHOLD(tq) &&
+			     compat_netif_carrier_ok(adapter->netdev))) {
+			vmxnet3_tq_wake(tq, adapter);
+		}
+		spin_unlock(&tq->tx_lock);
+	}
+	return completed;
+}
+
+
+static void
+vmxnet3_tq_cleanup(struct vmxnet3_tx_queue *tq,
+		   struct vmxnet3_adapter *adapter)
+{
+	while (tq->tx_ring.next2comp != tq->tx_ring.next2fill) {
+		struct vmxnet3_tx_buf_info *tbi;
+		union Vmxnet3_GenericDesc *gdesc;
+
+		tbi = tq->buf_info + tq->tx_ring.next2comp;
+		gdesc = tq->tx_ring.base + tq->tx_ring.next2comp;
+
+		vmxnet3_unmap_tx_buf(tbi, adapter->pdev);
+		if (tbi->skb) {
+			vmxnet3_dev_kfree_skb_any(adapter, tbi->skb);
+			tbi->skb = NULL;
+		}
+		vmxnet3_cmd_ring_adv_next2comp(&tq->tx_ring);
+	}
+
+	/* sanity check */
+#ifdef VMX86_DEBUG
+	{
+		/* verify all buffers are indeed unmapped and freed */
+		int i;
+		for (i = 0; i < tq->tx_ring.size; i++) {
+			BUG_ON(tq->buf_info[i].skb != NULL ||
+			       tq->buf_info[i].map_type != VMXNET3_MAP_NONE);
+		}
+	}
+#endif
+
+	tq->tx_ring.gen = VMXNET3_INIT_GEN;
+	tq->tx_ring.next2fill = tq->tx_ring.next2comp = 0;
+
+	tq->comp_ring.gen = VMXNET3_INIT_GEN;
+	tq->comp_ring.next2proc = 0;
+}
+
+
+/*
+ *	free rings and buf_info for the tx queue. There must be no pending pkt
+ *	in the tx ring. the .base fields of all rings and buf_info will be
+ *	set to NULL
+ */
+
+void
+vmxnet3_tq_destroy(struct vmxnet3_tx_queue *tq,
+		   struct vmxnet3_adapter *adapter)
+{
+	if (tq->tx_ring.base) {
+		pci_free_consistent(adapter->pdev, tq->tx_ring.size *
+				    sizeof(struct Vmxnet3_TxDesc),
+				    tq->tx_ring.base, tq->tx_ring.basePA);
+		tq->tx_ring.base = NULL;
+	}
+	if (tq->data_ring.base) {
+		pci_free_consistent(adapter->pdev, tq->data_ring.size *
+				    sizeof(struct Vmxnet3_TxDataDesc),
+				    tq->data_ring.base, tq->data_ring.basePA);
+		tq->data_ring.base = NULL;
+	}
+	if (tq->comp_ring.base) {
+		pci_free_consistent(adapter->pdev, tq->comp_ring.size *
+				    sizeof(struct Vmxnet3_TxCompDesc),
+				    tq->comp_ring.base, tq->comp_ring.basePA);
+		tq->comp_ring.base = NULL;
+	}
+	kfree(tq->buf_info);
+	tq->buf_info = NULL;
+}
+
+
+/*
+ *    reset all internal states and rings for a tx queue
+ * Side-effects:
+ *    1. contents of the rings are reset to 0
+ *    2. indices and gen of rings are reset
+ *    3. bookkeeping data is reset
+ */
+static void
+vmxnet3_tq_init(struct vmxnet3_tx_queue *tq,
+		struct vmxnet3_adapter *adapter)
+{
+	int i;
+
+	/* reset the tx ring contents to 0 and reset the tx ring states */
+	memset(tq->tx_ring.base, 0,
+	       tq->tx_ring.size * sizeof(struct Vmxnet3_TxDesc));
+	tq->tx_ring.next2fill = tq->tx_ring.next2comp = 0;
+	tq->tx_ring.gen = VMXNET3_INIT_GEN;
+
+	memset(tq->data_ring.base, 0,
+	       tq->data_ring.size * sizeof(struct Vmxnet3_TxDataDesc));
+
+	/* reset the tx comp ring contents to 0 and reset comp ring states */
+	memset(tq->comp_ring.base, 0,
+	       tq->comp_ring.size * sizeof(struct Vmxnet3_TxCompDesc));
+	tq->comp_ring.next2proc = 0;
+	tq->comp_ring.gen = VMXNET3_INIT_GEN;
+
+	/* reset the bookkeeping data */
+	memset(tq->buf_info, 0, sizeof(tq->buf_info[0]) * tq->tx_ring.size);
+	for (i = 0; i < tq->tx_ring.size; i++)
+		tq->buf_info[i].map_type = VMXNET3_MAP_NONE;
+
+	/* stats are not reset */
+}
+
+
+/*
+ * allocate and initialize rings for the tx queue, also allocate and
+ * initialize buf_info. Returns 0 on success, negative errno on failure.
+ */
+static int
+vmxnet3_tq_create(struct vmxnet3_tx_queue *tq,
+		  struct vmxnet3_adapter *adapter)
+{
+	BUG_ON(tq->tx_ring.size <= 0 ||
+	       tq->data_ring.size != tq->tx_ring.size);
+	BUG_ON((tq->tx_ring.size & VMXNET3_RING_SIZE_MASK) != 0);
+	BUG_ON(tq->tx_ring.base || tq->data_ring.base || tq->comp_ring.base ||
+	       tq->buf_info);
+
+	tq->tx_ring.base = pci_alloc_consistent(adapter->pdev,
+			   tq->tx_ring.size * sizeof(struct Vmxnet3_TxDesc),
+			   &tq->tx_ring.basePA);
+	if (!tq->tx_ring.base) {
+		printk(KERN_ERR "%s: failed to allocate tx ring\n",
+		       adapter->netdev->name);
+		goto err;
+	}
+
+	tq->data_ring.base = pci_alloc_consistent(adapter->pdev,
+			     tq->data_ring.size *
+			     sizeof(struct Vmxnet3_TxDataDesc),
+			     &tq->data_ring.basePA);
+	if (!tq->data_ring.base) {
+		printk(KERN_ERR "%s: failed to allocate data ring\n",
+		       adapter->netdev->name);
+		goto err;
+	}
+
+	tq->comp_ring.base = pci_alloc_consistent(adapter->pdev,
+			     tq->comp_ring.size *
+			     sizeof(struct Vmxnet3_TxCompDesc),
+			     &tq->comp_ring.basePA);
+	if (!tq->comp_ring.base) {
+		printk(KERN_ERR "%s: failed to allocate tx comp ring\n",
+		       adapter->netdev->name);
+		goto err;
+	}
+
+	tq->buf_info = kcalloc(tq->tx_ring.size, sizeof(tq->buf_info[0]),
+			       GFP_KERNEL);
+	if (!tq->buf_info) {
+		printk(KERN_ERR "%s: failed to allocate tx bufinfo\n",
+		       adapter->netdev->name);
+		goto err;
+	}
+
+	return 0;
+
+err:
+	vmxnet3_tq_destroy(tq, adapter);
+	return -ENOMEM;
+}
+
+
+/*
+ *    starting from ring->next2fill, allocate rx buffers for the given ring
+ *    of the rx queue and update the rx desc. stop after @num_to_alloc buffers
+ *    are allocated or allocation fails. Returns # of buffers allocated
+ *
+ * Side-effects:
+ *    1. rx descs are updated
+ *    2. ring->{gen, next2fill} are updated
+ *    3. uncommitted[ring_idx] is incremented
+ */
+
+static int
+vmxnet3_rq_alloc_rx_buf(struct vmxnet3_rx_queue *rq, u32 ring_idx,
+			int num_to_alloc, struct vmxnet3_adapter *adapter)
+{
+	int num_allocated = 0;
+	struct vmxnet3_rx_buf_info *rbi_base = rq->buf_info[ring_idx];
+	struct vmxnet3_cmd_ring *ring = &rq->rx_ring[ring_idx];
+	u32 val;
+
+	while (num_allocated < num_to_alloc) {
+		struct vmxnet3_rx_buf_info *rbi;
+		union Vmxnet3_GenericDesc *gd;
+
+		rbi = rbi_base + ring->next2fill;
+		gd = ring->base + ring->next2fill;
+
+		if (rbi->buf_type == VMXNET3_RX_BUF_SKB) {
+			if (rbi->skb == NULL) {
+				rbi->skb = vmxnet3_dev_alloc_skb(adapter,
+					 	rbi->len + COMPAT_NET_IP_ALIGN);
+				if (unlikely(rbi->skb == NULL)) {
+					rq->stats.rx_buf_alloc_failure++;
+					break;
+				}
+				rbi->skb->dev = adapter->netdev;
+
+				if (!adapter->is_shm)
+					skb_reserve(rbi->skb, NET_IP_ALIGN);
+				rbi->dma_addr = vmxnet3_map_single(
+						adapter, rbi->skb, 0,
+						rbi->len, PCI_DMA_FROMDEVICE);
+			} else {
+				/* rx buffer skipped by the device */
+			}
+			val = VMXNET3_RXD_BTYPE_HEAD << VMXNET3_RXD_BTYPE_SHIFT;
+		} else {
+			BUG_ON(rbi->buf_type != VMXNET3_RX_BUF_PAGE ||
+			       rbi->len  != PAGE_SIZE);
+
+			if (rbi->page == NULL) {
+				rbi->page = vmxnet3_alloc_page(adapter);
+				if (unlikely(rbi->page == NULL)) {
+					rq->stats.rx_buf_alloc_failure++;
+					break;
+				}
+				rbi->dma_addr = vmxnet3_map_page(adapter,
+						rbi->page, 0, PAGE_SIZE,
+						PCI_DMA_FROMDEVICE);
+			} else {
+				/* rx buffers skipped by the device */
+			}
+			val = VMXNET3_RXD_BTYPE_BODY << VMXNET3_RXD_BTYPE_SHIFT;
+		}
+
+		BUG_ON(rbi->dma_addr == 0);
+		gd->rxd.addr = cpu_to_le64(rbi->dma_addr);
+		gd->dword[2] = cpu_to_le32((ring->gen << VMXNET3_RXD_GEN_SHIFT)
+					   | val | rbi->len);
+
+		num_allocated++;
+		vmxnet3_cmd_ring_adv_next2fill(ring);
+	}
+	rq->uncommitted[ring_idx] += num_allocated;
+
+	dev_dbg(&adapter->pdev->dev, "alloc_rx_buf: %d allocated, next2fill "
+		"%u, next2comp %u, uncommited %u\n", num_allocated,
+		ring->next2fill, ring->next2comp, rq->uncommitted[ring_idx]);
+
+	/* so that the device can distinguish a full ring and an empty ring */
+	BUG_ON(num_allocated != 0 && ring->next2fill == ring->next2comp);
+
+	return num_allocated;
+}
+
+
+/*
+ * It assumes the skb still has space to accommodate the frag. It only
+ * increments skb->data_len
+ */
+
+static void
+vmxnet3_append_frag(struct sk_buff *skb, struct Vmxnet3_RxCompDesc *rcd,
+		    struct vmxnet3_rx_buf_info *rbi)
+{
+	struct skb_frag_struct *frag = skb_shinfo(skb)->frags +
+		skb_shinfo(skb)->nr_frags;
+
+	BUG_ON(skb_shinfo(skb)->nr_frags >= MAX_SKB_FRAGS);
+
+	frag->page = rbi->page;
+	frag->page_offset = 0;
+	frag->size = rcd->len;
+	skb->data_len += frag->size;
+	skb_shinfo(skb)->nr_frags++;
+}
+
+
+/*
+ * Map the tx buffer and set up ONLY TXD.{addr, len, gen} based on the mapping.
+ * It sets the other fields of the descriptors to 0.
+ * Side Effects :
+ *    1. the corresponding buf_info entries are upated,
+ *    2. ring indices are advanced
+ */
+
+static void
+vmxnet3_map_pkt(struct sk_buff *skb, struct vmxnet3_tx_ctx *ctx,
+		struct vmxnet3_tx_queue *tq, struct pci_dev *pdev,
+		struct vmxnet3_adapter *adapter)
+{
+	u32 dw2, len;
+	unsigned long buf_offset;
+	int i;
+	union Vmxnet3_GenericDesc *gdesc;
+	struct vmxnet3_tx_buf_info *tbi = NULL;
+
+	BUG_ON(ctx->copy_size > skb_headlen(skb));
+
+	/* use the previous gen bit for the SOP desc */
+	dw2 = (tq->tx_ring.gen ^ 0x1) << VMXNET3_TXD_GEN_SHIFT;
+
+	ctx->sop_txd = tq->tx_ring.base + tq->tx_ring.next2fill;
+	gdesc = ctx->sop_txd; /* both loops below can be skipped */
+
+	/* no need to map the buffer if headers are copied */
+	if (ctx->copy_size) {
+		BUG_ON(VMXNET3_TXDESC_GET_GEN(&(ctx->sop_txd->txd)) ==
+		       tq->tx_ring.gen);
+
+		ctx->sop_txd->txd.addr = cpu_to_le64(tq->data_ring.basePA +
+					tq->tx_ring.next2fill *
+					sizeof(struct Vmxnet3_TxDataDesc));
+		ctx->sop_txd->dword[2] = cpu_to_le32(dw2 | ctx->copy_size);
+		ctx->sop_txd->dword[3] = 0;
+
+		tbi = tq->buf_info + tq->tx_ring.next2fill;
+		tbi->map_type = VMXNET3_MAP_NONE;
+
+		dev_dbg(&adapter->pdev->dev, "txd[%u]: 0x%llu 0x%x 0x%x\n",
+			tq->tx_ring.next2fill,
+			le64_to_cpu(ctx->sop_txd->txd.addr),
+			ctx->sop_txd->dword[2], ctx->sop_txd->dword[3]);
+		vmxnet3_cmd_ring_adv_next2fill(&tq->tx_ring);
+
+		/* use the right gen for non-SOP desc */
+		dw2 = tq->tx_ring.gen << VMXNET3_TXD_GEN_SHIFT;
+	}
+
+	/* linear part can use multiple tx desc if it's big */
+	len = vmxnet3_skb_headlen(adapter, skb) - ctx->copy_size;
+	buf_offset = ctx->copy_size;
+	while (len) {
+		u32 buf_size;
+
+		buf_size = len > VMXNET3_MAX_TX_BUF_SIZE ?
+			   VMXNET3_MAX_TX_BUF_SIZE : len;
+
+		tbi = tq->buf_info + tq->tx_ring.next2fill;
+		tbi->map_type = VMXNET3_MAP_SINGLE;
+		tbi->dma_addr = vmxnet3_map_single(adapter, skb, buf_offset,
+				buf_size, PCI_DMA_TODEVICE);
+
+		tbi->len = buf_size; /* this automatically convert 2^14 to 0 */
+
+		gdesc = tq->tx_ring.base + tq->tx_ring.next2fill;
+		BUG_ON(gdesc->txd.gen == tq->tx_ring.gen);
+
+		gdesc->txd.addr = cpu_to_le64(tbi->dma_addr);
+		gdesc->dword[2] = cpu_to_le32(dw2 | buf_size);
+		gdesc->dword[3] = 0;
+
+		dev_dbg(&adapter->pdev->dev,
+			"txd[%u]: 0x%llu 0x%x 0x%x\n",
+			tq->tx_ring.next2fill, le64_to_cpu(gdesc->txd.addr),
+			le32_to_cpu(gdesc->dword[2]), gdesc->dword[3]);
+		vmxnet3_cmd_ring_adv_next2fill(&tq->tx_ring);
+		dw2 = tq->tx_ring.gen << VMXNET3_TXD_GEN_SHIFT;
+
+		len -= buf_size;
+		buf_offset += buf_size;
+
+		if (adapter->is_shm) {
+		/*
+		 * The linear region of the skb is never larger than a page, so
+		 * it always fits into one descriptor.
+		 */
+			BUG_ON(len != 0);
+		}
+	}
+
+	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+		struct skb_frag_struct *frag = &skb_shinfo(skb)->frags[i];
+
+		tbi = tq->buf_info + tq->tx_ring.next2fill;
+		tbi->map_type = VMXNET3_MAP_PAGE;
+		tbi->dma_addr = vmxnet3_map_page(adapter, frag->page,
+						frag->page_offset, frag->size,
+						PCI_DMA_TODEVICE);
+
+		tbi->len = frag->size;
+
+		gdesc = tq->tx_ring.base + tq->tx_ring.next2fill;
+		BUG_ON(gdesc->txd.gen == tq->tx_ring.gen);
+
+		gdesc->txd.addr = cpu_to_le64(tbi->dma_addr);
+		gdesc->dword[2] = cpu_to_le32(dw2 | frag->size);
+		gdesc->dword[3] = 0;
+
+		dev_dbg(&adapter->pdev->dev,
+			"txd[%u]: 0x%llu %u %u\n",
+			tq->tx_ring.next2fill, le64_to_cpu(gdesc->txd.addr),
+			le32_to_cpu(gdesc->dword[2]), gdesc->dword[3]);
+		vmxnet3_cmd_ring_adv_next2fill(&tq->tx_ring);
+		dw2 = tq->tx_ring.gen << VMXNET3_TXD_GEN_SHIFT;
+	}
+
+	ctx->eop_txd = gdesc;
+
+	/* set the last buf_info for the pkt */
+	tbi->skb = skb;
+	tbi->sop_idx = ctx->sop_txd - tq->tx_ring.base;
+}
+
+
+/*
+ *    parse and copy relevant protocol headers:
+ *     For a tso pkt, relevant headers are L2/3/4 including options
+ *     For a pkt requesting csum offloading, they are L2/3 and may include L4
+ *     if it's a TCP/UDP pkt
+ *
+ *    The implementation works only when h/w vlan insertion is used, see PR
+ *    171928
+ *
+ * Result:
+ *    -1:  error happens during parsing
+ *     0:  protocol headers parsed, but too big to be copied
+ *     1:  protocol headers parsed and copied
+ *
+ * Side-effects:
+ *    1. related *ctx fields are updated.
+ *    2. ctx->copy_size is # of bytes copied
+ *    3. the portion copied is guaranteed to be in the linear part
+ *
+ */
+static int
+vmxnet3_parse_and_copy_hdr(struct sk_buff *skb, struct vmxnet3_tx_queue *tq,
+			   struct vmxnet3_tx_ctx *ctx,
+			   struct vmxnet3_adapter *adapter)
+{
+	struct Vmxnet3_TxDataDesc *tdd;
+
+	if (ctx->mss) {
+		ctx->eth_ip_hdr_size = compat_skb_transport_offset(skb);
+		ctx->l4_hdr_size = compat_skb_tcp_header(skb)->doff * 4;
+		ctx->copy_size = ctx->eth_ip_hdr_size + ctx->l4_hdr_size;
+	} else {
+		unsigned int pull_size;
+
+		if (skb->ip_summed == VM_TX_CHECKSUM_PARTIAL) {
+			ctx->eth_ip_hdr_size = compat_skb_transport_offset(skb);
+
+			if (ctx->ipv4) {
+				struct iphdr *iph = (struct iphdr *)
+						    compat_skb_ip_header(skb);
+				if (iph->protocol == IPPROTO_TCP) {
+					pull_size = ctx->eth_ip_hdr_size +
+						    sizeof(struct tcphdr);
+
+					if (unlikely(!compat_pskb_may_pull(skb,
+								pull_size))) {
+						goto err;
+					}
+					ctx->l4_hdr_size =
+					   compat_skb_tcp_header(skb)->doff * 4;
+				} else if (iph->protocol == IPPROTO_UDP) {
+					ctx->l4_hdr_size =
+							sizeof(struct udphdr);
+				} else {
+					ctx->l4_hdr_size = 0;
+				}
+			} else {
+				/* for simplicity, don't copy L4 headers */
+				ctx->l4_hdr_size = 0;
+			}
+			ctx->copy_size = ctx->eth_ip_hdr_size +
+					 ctx->l4_hdr_size;
+		} else {
+			ctx->eth_ip_hdr_size = 0;
+			ctx->l4_hdr_size = 0;
+			/* copy as much as allowed */
+			ctx->copy_size = min((unsigned int)VMXNET3_HDR_COPY_SIZE
+					   , vmxnet3_skb_headlen(adapter, skb));
+		}
+
+		if(!adapter->is_shm) {
+		         /* make sure headers are accessible directly */
+			if (unlikely(!compat_pskb_may_pull(skb,
+							ctx->copy_size)))
+				goto err;
+
+		}
+	}
+
+	if (unlikely(ctx->copy_size > VMXNET3_HDR_COPY_SIZE)) {
+		tq->stats.oversized_hdr++;
+		ctx->copy_size = 0;
+		return 0;
+	}
+
+	tdd = tq->data_ring.base + tq->tx_ring.next2fill;
+	BUG_ON(ctx->copy_size > vmxnet3_skb_headlen(adapter, skb));
+
+	if (!adapter->is_shm) {
+		memcpy(tdd->data, skb->data, ctx->copy_size);
+	} else {
+		void *virt = kmap(VMXNET3_SHM_IDX2PAGE(adapter->shm,
+				  VMXNET3_SHM_SKB_GETIDX(skb)));
+		memcpy(tdd->data, virt, ctx->copy_size);
+		kunmap(VMXNET3_SHM_IDX2PAGE(adapter->shm,
+		       VMXNET3_SHM_SKB_GETIDX(skb)));
+	}
+
+	dev_dbg(&adapter->pdev->dev, "copy %u bytes to dataRing[%u]\n",
+		ctx->copy_size, tq->tx_ring.next2fill);
+	return 1;
+
+err:
+	return -1;
+}
+
+
+/*
+ *    Fix pkt headers for tso. ip hdr and tcp hdr are changed
+ */
+
+static void
+vmxnet3_prepare_tso(struct sk_buff *skb, struct vmxnet3_tx_ctx *ctx)
+{
+	struct tcphdr *tcph = compat_skb_tcp_header(skb);
+	if (ctx->ipv4) {
+		struct iphdr *iph = compat_skb_ip_header(skb);
+		iph->check = 0;
+		tcph->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr, 0,
+						 IPPROTO_TCP, 0);
+#ifdef NETIF_F_TSO6
+	} else {
+		struct ipv6hdr *iph = (struct ipv6hdr *)
+				      compat_skb_network_header(skb);
+		tcph->check = ~csum_ipv6_magic(&iph->saddr, &iph->daddr, 0,
+					       IPPROTO_TCP, 0);
+#endif
+	}
+}
+
+inline void vmxnet3_le32_add_cpu(uint32 *addTo, uint32 addThis)
+{
+	*addTo = cpu_to_le32(le32_to_cpu(*addTo) + addThis);
+}
+
+
+/*
+ *    transmit a pkt thru a given tq
+ *
+ * Result:
+ *    COMPAT_NETDEV_TX_OK:      descriptors are setup successfully
+ *    COMPAT_NETDEV_TX_OK:      error occured, the pkt is dropped
+ *    COMPAT_NETDEV_TX_BUSY:    tx ring is full, queue is stopped
+ *
+ * Side-effects:
+ *    1. tx ring may be changed
+ *    2. tq stats may be updated accordingly
+ *    3. shared->txNumDeferred may be updated
+ */
+
+int
+vmxnet3_tq_xmit(struct sk_buff *skb,
+		struct vmxnet3_tx_queue *tq,
+		struct vmxnet3_adapter *adapter,
+		struct net_device *netdev)
+{
+	int ret;
+	u32 count;
+	unsigned long flags;
+	struct vmxnet3_tx_ctx ctx;
+	union Vmxnet3_GenericDesc *gdesc;
+#ifdef __BIG_ENDIAN_BITFIELD
+	/* Use temporary descriptor to avoid touching bits multiple times */
+	union Vmxnet3_GenericDesc tempTxDesc;
+#endif
+
+	/* conservatively estimate # of descriptors to use */
+	count = VMXNET3_TXD_NEEDED(vmxnet3_skb_headlen(adapter, skb)) +
+		skb_shinfo(skb)->nr_frags + 1;
+
+	ctx.ipv4 = (skb->protocol == __constant_ntohs(ETH_P_IP));
+
+	ctx.mss = compat_skb_mss(skb);
+	if (ctx.mss) {
+		if (compat_skb_header_cloned(skb)) {
+			if (unlikely(pskb_expand_head(skb, 0, 0,
+						      GFP_ATOMIC) != 0)) {
+				tq->stats.drop_tso++;
+				goto drop_pkt;
+			}
+			tq->stats.copy_skb_header++;
+		}
+		vmxnet3_prepare_tso(skb, &ctx);
+	} else {
+		if (unlikely(count > VMXNET3_MAX_TXD_PER_PKT)) {
+			if (unlikely(adapter->is_shm)) {
+				BUG_ON(count > VMXNET3_MAX_TXD_PER_PKT_SHM);
+				if (count > VMXNET3_MAX_TXD_PER_PKT_SHM) {
+					tq->stats.drop_too_many_frags++;
+					goto drop_pkt;
+				}
+			} else {
+				/* non-tso pkts must not use more than
+				 * VMXNET3_MAX_TXD_PER_PKT entries
+				 */
+				if (compat_skb_linearize(skb) != 0) {
+					tq->stats.drop_too_many_frags++;
+					goto drop_pkt;
+				}
+				tq->stats.linearized++;
+
+				/* recalculate the # of descriptors to use */
+				count = VMXNET3_TXD_NEEDED(vmxnet3_skb_headlen(
+							adapter, skb)) + 1;
+			}
+		}
+	}
+
+	ret = vmxnet3_parse_and_copy_hdr(skb, tq, &ctx, adapter);
+	if (ret >= 0) {
+		BUG_ON(ret <= 0 && ctx.copy_size != 0);
+		/* hdrs parsed, check against other limits */
+		if (ctx.mss) {
+			if (unlikely(ctx.eth_ip_hdr_size + ctx.l4_hdr_size >
+				     VMXNET3_MAX_TX_BUF_SIZE)) {
+				goto hdr_too_big;
+			}
+		} else {
+			if (skb->ip_summed == VM_TX_CHECKSUM_PARTIAL) {
+				if (unlikely(ctx.eth_ip_hdr_size +
+					     compat_skb_csum_offset(skb) >
+					     VMXNET3_MAX_CSUM_OFFSET)) {
+					goto hdr_too_big;
+				}
+			}
+		}
+	} else {
+		tq->stats.drop_hdr_inspect_err++;
+		goto drop_pkt;
+	}
+
+	spin_lock_irqsave(&tq->tx_lock, flags);
+
+	if (count > vmxnet3_cmd_ring_desc_avail(&tq->tx_ring)) {
+		tq->stats.tx_ring_full++;
+		dev_dbg(&adapter->pdev->dev, "tx queue stopped on %s, next2comp"
+			" %u next2fill %u\n", adapter->netdev->name,
+			tq->tx_ring.next2comp, tq->tx_ring.next2fill);
+
+		vmxnet3_tq_stop(tq, adapter);
+		spin_unlock_irqrestore(&tq->tx_lock, flags);
+		return COMPAT_NETDEV_TX_BUSY;
+	}
+
+	/* fill tx descs related to addr & len */
+	vmxnet3_map_pkt(skb, &ctx, tq, adapter->pdev, adapter);
+
+	/* setup the EOP desc */
+	ctx.eop_txd->dword[3] = cpu_to_le32(VMXNET3_TXD_CQ | VMXNET3_TXD_EOP);
+
+	/* setup the SOP desc */
+#ifdef __BIG_ENDIAN_BITFIELD
+	gdesc = &tempTxDesc;
+	gdesc->dword[2] = ctx.sop_txd->dword[2];
+	gdesc->dword[3] = ctx.sop_txd->dword[3];
+#else
+	gdesc = ctx.sop_txd;
+#endif
+	if (ctx.mss) {
+		gdesc->txd.hlen = ctx.eth_ip_hdr_size + ctx.l4_hdr_size;
+		gdesc->txd.om = VMXNET3_OM_TSO;
+		gdesc->txd.msscof = ctx.mss;
+		vmxnet3_le32_add_cpu(&tq->shared->txNumDeferred, (skb->len -
+			     gdesc->txd.hlen + ctx.mss - 1) / ctx.mss);
+	} else {
+		if (skb->ip_summed == VM_TX_CHECKSUM_PARTIAL) {
+			gdesc->txd.hlen = ctx.eth_ip_hdr_size;
+			gdesc->txd.om = VMXNET3_OM_CSUM;
+			gdesc->txd.msscof = ctx.eth_ip_hdr_size +
+					    compat_skb_csum_offset(skb);
+		} else {
+			gdesc->txd.om = 0;
+			gdesc->txd.msscof = 0;
+		}
+		vmxnet3_le32_add_cpu(&tq->shared->txNumDeferred, 1);
+	}
+
+	if (vlan_tx_tag_present(skb)) {
+		gdesc->txd.ti = 1;
+		gdesc->txd.tci = vlan_tx_tag_get(skb);
+	}
+
+	/* finally flips the GEN bit of the SOP desc. */
+	gdesc->dword[2] = cpu_to_le32(le32_to_cpu(gdesc->dword[2]) ^
+						  VMXNET3_TXD_GEN);
+#ifdef __BIG_ENDIAN_BITFIELD
+	/* Finished updating in bitfields of Tx Desc, so write them in original
+	 * place.
+	 */
+	vmxnet3_TxDescToLe((struct Vmxnet3_TxDesc *)gdesc,
+			   (struct Vmxnet3_TxDesc *)ctx.sop_txd);
+	gdesc = ctx.sop_txd;
+#endif
+	dev_dbg(&adapter->pdev->dev,
+		"txd[%u]: SOP 0x%llu 0x%x 0x%x\n",
+		(u32)((union Vmxnet3_GenericDesc *)ctx.sop_txd -
+		tq->tx_ring.base), le64_to_cpu(gdesc->txd.addr),
+		le32_to_cpu(gdesc->dword[2]), le32_to_cpu(gdesc->dword[3]));
+
+	spin_unlock_irqrestore(&tq->tx_lock, flags);
+
+	if (le32_to_cpu(tq->shared->txNumDeferred) >=
+					le32_to_cpu(tq->shared->txThreshold)) {
+		tq->shared->txNumDeferred = 0;
+		VMXNET3_WRITE_BAR0_REG(adapter, VMXNET3_REG_TXPROD,
+				       tq->tx_ring.next2fill);
+	}
+	netdev->trans_start = jiffies;
+
+	return COMPAT_NETDEV_TX_OK;
+
+hdr_too_big:
+	tq->stats.drop_oversized_hdr++;
+drop_pkt:
+	tq->stats.drop_total++;
+	vmxnet3_dev_kfree_skb(adapter, skb);
+	return COMPAT_NETDEV_TX_OK;
+}
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
+static int
+#else
+static netdev_tx_t
+#endif
+vmxnet3_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+
+	if (adapter->is_shm)
+		return vmxnet3_shm_start_tx(skb, netdev);
+	else
+		return vmxnet3_tq_xmit(skb, &adapter->tx_queue, adapter, netdev);
+}
+
+
+/* called to process csum related bits in the EOP RCD descriptor */
+static void
+vmxnet3_rx_csum(struct vmxnet3_adapter *adapter,
+		struct sk_buff *skb,
+		union Vmxnet3_GenericDesc *gdesc)
+{
+	if (!gdesc->rcd.cnc && adapter->rxcsum) {
+		/* typical case: TCP/UDP over IP and both csums are correct */
+		if ((le32_to_cpu(gdesc->dword[3]) & VMXNET3_RCD_CSUM_OK) ==
+							VMXNET3_RCD_CSUM_OK) {
+			skb->ip_summed = VM_CHECKSUM_UNNECESSARY;
+			BUG_ON(!(gdesc->rcd.tcp || gdesc->rcd.udp));
+			BUG_ON(!(gdesc->rcd.v4  || gdesc->rcd.v6));
+			BUG_ON(gdesc->rcd.frg);
+		} else {
+			if (gdesc->rcd.csum) {
+				skb->csum = htons(gdesc->rcd.csum);
+				skb->ip_summed = VM_RX_CHECKSUM_PARTIAL;
+			} else {
+				skb->ip_summed = CHECKSUM_NONE;
+			}
+		}
+	} else {
+		skb->ip_summed = CHECKSUM_NONE;
+	}
+}
+
+
+/*
+ * called when ERR bit is set for a received pkt. The desc and the associated
+ * rx buffer have not been processed yet.
+ *
+ * Side-effects:
+ *    1. up the stat counters
+ *    2. free the skb if needed
+ *    3. reset ctx->skb
+ */
+
+static void
+vmxnet3_rx_error(struct vmxnet3_rx_queue *rq, struct Vmxnet3_RxCompDesc *rcd,
+		 struct vmxnet3_rx_ctx *ctx,  struct vmxnet3_adapter *adapter)
+{
+	rq->stats.drop_err++;
+	if (!rcd->fcs)
+		rq->stats.drop_fcs++;
+
+	rq->stats.drop_total++;
+
+	/*
+	 * We do not unmap and chain the rx buffer to the skb.
+	 * We basically pretend this buffer is not used and will be recycled
+	 * by vmxnet3_rq_alloc_rx_buf()
+	 */
+
+	/*
+	 * ctx->skb may be NULL if this is the first and the only one
+	 * desc for the pkt
+	 */
+	if (ctx->skb)
+		vmxnet3_dev_kfree_skb_irq(adapter, ctx->skb);
+
+	ctx->skb = NULL;
+}
+
+/* process the rx completion ring of the given rx queue. Quota specifies the
+ * max # of rx completion entries to be processed. Returns # of descs completed.
+ */
+static int
+#ifdef VMXNET3_NAPI
+vmxnet3_rq_rx_complete(struct vmxnet3_rx_queue *rq,
+		       struct vmxnet3_adapter *adapter, int quota)
+#else
+vmxnet3_rq_rx_complete(struct vmxnet3_rx_queue *rq,
+		       struct vmxnet3_adapter *adapter)
+#endif
+{
+	static u32 rxprod_reg[2] = {VMXNET3_REG_RXPROD, VMXNET3_REG_RXPROD2};
+	u32 num_rxd = 0;
+	struct Vmxnet3_RxCompDesc *rcd;
+	struct vmxnet3_rx_ctx *ctx = &rq->rx_ctx;
+#ifdef __BIG_ENDIAN_BITFIELD
+	struct Vmxnet3_RxDesc rxCmdDesc;
+	struct Vmxnet3_RxCompDesc rxComp;
+#endif
+	vmxnet3_getRxComp(rcd, &rq->comp_ring.base[rq->comp_ring.next2proc].rcd,
+			  &rxComp);
+	while (rcd->gen == rq->comp_ring.gen) {
+		struct vmxnet3_rx_buf_info *rbi;
+		struct sk_buff *skb;
+		int num_to_alloc;
+		struct Vmxnet3_RxDesc *rxd;
+		u32 idx, ring_idx;
+#ifdef VMXNET3_NAPI
+		if (num_rxd >= quota) {
+			/* we may stop even before we see the EOP desc of
+			 * the current pkt
+			 */
+			break;
+		}
+		num_rxd++;
+#endif
+
+		idx = rcd->rxdIdx;
+		ring_idx = rcd->rqID == rq->qid ? 0 : 1;
+		vmxnet3_getRxDesc(rxd, &rq->rx_ring[ring_idx].base[idx].rxd,
+				  &rxCmdDesc);
+		rbi = rq->buf_info[ring_idx] + idx;
+
+		BUG_ON(rcd->len > rxd->len);
+		BUG_ON(rxd->addr != rbi->dma_addr ||
+		       rxd->len != rbi->len);
+
+		if (unlikely(rcd->eop && rcd->err)) {
+			vmxnet3_rx_error(rq, rcd, ctx, adapter);
+			goto rcd_done;
+		}
+
+		if (rcd->sop) { /* first buf of the pkt */
+			BUG_ON(rxd->btype != VMXNET3_RXD_BTYPE_HEAD ||
+			       rcd->rqID != rq->qid);
+
+			BUG_ON(rbi->buf_type != VMXNET3_RX_BUF_SKB);
+			BUG_ON(ctx->skb != NULL || rbi->skb == NULL);
+
+			if (unlikely(rcd->len == 0)) {
+				/* Pretend the rx buffer is skipped. */
+				BUG_ON(!(rcd->sop && rcd->eop));
+				dev_dbg(&adapter->pdev->dev, "rxRing[%u][%u] 0"
+					" length\n", ring_idx, idx);
+				goto rcd_done;
+			}
+
+			ctx->skb = rbi->skb;
+			rbi->skb = NULL;
+
+			pci_unmap_single(adapter->pdev, rbi->dma_addr, rbi->len,
+					 PCI_DMA_FROMDEVICE);
+
+			vmxnet3_skb_put(adapter, ctx->skb, rcd->len);
+		} else {
+			BUG_ON(ctx->skb == NULL);
+			/* non SOP buffer must be type 1 in most cases */
+			if (rbi->buf_type == VMXNET3_RX_BUF_PAGE) {
+				BUG_ON(rxd->btype != VMXNET3_RXD_BTYPE_BODY);
+
+				if (rcd->len) {
+					pci_unmap_page(adapter->pdev,
+						       rbi->dma_addr, rbi->len,
+						       PCI_DMA_FROMDEVICE);
+
+					vmxnet3_append_frag(ctx->skb, rcd, rbi);
+					rbi->page = NULL;
+				}
+			} else {
+				/*
+				 * The only time a non-SOP buffer is type 0 is
+				 * when it's EOP and error flag is raised, which
+				 * has already been handled.
+				 */
+				BUG_ON(TRUE);
+			}
+		}
+
+		skb = ctx->skb;
+		if (rcd->eop) {
+			if (adapter->is_shm) {
+				vmxnet3_shm_rx_skb(adapter, skb);
+
+				wake_up(&adapter->shm->rxq);
+			} else {
+				skb->len += skb->data_len;
+				skb->truesize += skb->data_len;
+
+				vmxnet3_rx_csum(adapter, skb,
+					(union Vmxnet3_GenericDesc *)rcd);
+				skb->protocol = eth_type_trans(skb,
+							       adapter->netdev);
+
+#ifdef VMXNET3_NAPI
+				if (unlikely(adapter->vlan_grp && rcd->ts)) {
+					vlan_hwaccel_receive_skb(skb,
+						adapter->vlan_grp, rcd->tci);
+				} else {
+					netif_receive_skb(skb);
+				}
+#else
+				if (unlikely(adapter->vlan_grp && rcd->ts)) {
+					vlan_hwaccel_rx(skb, adapter->vlan_grp,
+							rcd->tci);
+				} else {
+					netif_rx(skb);
+				}
+#endif
+			}
+
+			adapter->netdev->last_rx = jiffies;
+			ctx->skb = NULL;
+		}
+
+rcd_done:
+		/* device may skip some rx descs */
+		rq->rx_ring[ring_idx].next2comp = idx;
+		VMXNET3_INC_RING_IDX_ONLY(rq->rx_ring[ring_idx].next2comp,
+					  rq->rx_ring[ring_idx].size);
+
+		/* refill rx buffers frequently to avoid starving the h/w */
+		num_to_alloc = vmxnet3_cmd_ring_desc_avail(rq->rx_ring +
+							   ring_idx);
+		if (unlikely(num_to_alloc > VMXNET3_RX_ALLOC_THRESHOLD(rq,
+							ring_idx, adapter))) {
+			vmxnet3_rq_alloc_rx_buf(rq, ring_idx, num_to_alloc,
+						adapter);
+
+			/* if needed, update the register */
+			if (unlikely(rq->shared->updateRxProd)) {
+				VMXNET3_WRITE_BAR0_REG(adapter,
+					rxprod_reg[ring_idx] + rq->qid * 8,
+					rq->rx_ring[ring_idx].next2fill);
+				rq->uncommitted[ring_idx] = 0;
+			}
+		}
+
+		vmxnet3_comp_ring_adv_next2proc(&rq->comp_ring);
+		vmxnet3_getRxComp(rcd,
+		     &rq->comp_ring.base[rq->comp_ring.next2proc].rcd, &rxComp);
+	}
+
+	return num_rxd;
+}
+
+
+/*
+ * Unmap and free the rx buffers allocated to the rx queue. Other resources
+ * are NOT freed. This is the counterpart of vmxnet3_rq_init()
+ * Side-effects:
+ *    1. indices and gen of each ring are reset to the initial value
+ *    2. buf_info[] and buf_info2[] are cleared.
+ */
+
+static void
+vmxnet3_rq_cleanup(struct vmxnet3_rx_queue *rq,
+		   struct vmxnet3_adapter *adapter)
+{
+	u32 i, ring_idx;
+	struct Vmxnet3_RxDesc *rxd;
+
+	for (ring_idx = 0; ring_idx < 2; ring_idx++) {
+		for (i = 0; i < rq->rx_ring[ring_idx].size; i++) {
+#ifdef __BIG_ENDIAN_BITFIELD
+			struct Vmxnet3_RxDesc rxDesc;
+#endif
+			vmxnet3_getRxDesc(rxd,
+				&rq->rx_ring[ring_idx].base[i].rxd, &rxDesc);
+
+			if (rxd->btype == VMXNET3_RXD_BTYPE_HEAD &&
+					rq->buf_info[ring_idx][i].skb) {
+				pci_unmap_single(adapter->pdev, rxd->addr,
+						 rxd->len, PCI_DMA_FROMDEVICE);
+				vmxnet3_dev_kfree_skb(adapter,
+						rq->buf_info[ring_idx][i].skb);
+				rq->buf_info[ring_idx][i].skb = NULL;
+			} else if (rxd->btype == VMXNET3_RXD_BTYPE_BODY &&
+					rq->buf_info[ring_idx][i].page) {
+				pci_unmap_page(adapter->pdev, rxd->addr,
+					       rxd->len, PCI_DMA_FROMDEVICE);
+				vmxnet3_put_page(adapter,
+						rq->buf_info[ring_idx][i].page);
+				rq->buf_info[ring_idx][i].page = NULL;
+			}
+		}
+
+		rq->rx_ring[ring_idx].gen = VMXNET3_INIT_GEN;
+		rq->rx_ring[ring_idx].next2fill =
+					rq->rx_ring[ring_idx].next2comp = 0;
+		rq->uncommitted[ring_idx] = 0;
+	}
+
+	rq->comp_ring.gen = VMXNET3_INIT_GEN;
+	rq->comp_ring.next2proc = 0;
+}
+
+
+/*
+ *    Free rings and buf_info for the rx queue. The rx buffers must have
+ *    ALREADY been freed. the .base fields of all rings will be set to NULL
+ */
+
+void
+vmxnet3_rq_destroy(struct vmxnet3_rx_queue *rq,
+		struct vmxnet3_adapter *adapter)
+{
+	int i;
+
+#ifdef VMX86_DEBUG
+	/* all rx buffers must have already been freed */
+	{
+		int j;
+
+		for (i = 0; i < 2; i++) {
+			if (rq->buf_info[i]) {
+				for (j = 0; j < rq->rx_ring[i].size; j++) {
+					BUG_ON(rq->buf_info[i][j].page != NULL);
+				}
+			}
+		}
+	}
+#endif
+
+
+	kfree(rq->buf_info[0]);
+
+	for (i = 0; i < 2; i++) {
+		if (rq->rx_ring[i].base) {
+			pci_free_consistent(adapter->pdev, rq->rx_ring[i].size
+					    * sizeof(struct Vmxnet3_RxDesc),
+					    rq->rx_ring[i].base,
+					    rq->rx_ring[i].basePA);
+			rq->rx_ring[i].base = NULL;
+		}
+		rq->buf_info[i] = NULL;
+	}
+
+	if (rq->comp_ring.base) {
+		pci_free_consistent(adapter->pdev, rq->comp_ring.size *
+				    sizeof(struct Vmxnet3_RxCompDesc),
+				    rq->comp_ring.base, rq->comp_ring.basePA);
+		rq->comp_ring.base = NULL;
+	}
+}
+
+
+/*
+ *    initialize buf_info, allocate rx buffers and fill the rx rings. On
+ *    failure, the rx buffers already allocated are NOT freed
+ */
+
+static int
+vmxnet3_rq_init(struct vmxnet3_rx_queue *rq,
+		struct vmxnet3_adapter  *adapter)
+{
+	int i;
+
+	BUG_ON(adapter->rx_buf_per_pkt <= 0 ||
+	       rq->rx_ring[0].size % adapter->rx_buf_per_pkt != 0);
+	/* initialize buf_info */
+	for (i = 0; i < rq->rx_ring[0].size; i++) {
+		BUG_ON(rq->buf_info[0][i].skb != NULL);
+		/* 1st buf for a pkt is skbuff */
+		if (i % adapter->rx_buf_per_pkt == 0) {
+			rq->buf_info[0][i].buf_type = VMXNET3_RX_BUF_SKB;
+			rq->buf_info[0][i].len = adapter->skb_buf_size;
+		} else { /* subsequent bufs for a pkt is frag */
+			rq->buf_info[0][i].buf_type = VMXNET3_RX_BUF_PAGE;
+			rq->buf_info[0][i].len = PAGE_SIZE;
+		}
+	}
+	for (i = 0; i < rq->rx_ring[1].size; i++) {
+		BUG_ON(rq->buf_info[1][i].page != NULL);
+		rq->buf_info[1][i].buf_type = VMXNET3_RX_BUF_PAGE;
+		rq->buf_info[1][i].len = PAGE_SIZE;
+	}
+
+	/* reset internal state and allocate buffers for both rings */
+	for (i = 0; i < 2; i++) {
+		rq->rx_ring[i].next2fill = rq->rx_ring[i].next2comp = 0;
+		rq->uncommitted[i] = 0;
+
+		memset(rq->rx_ring[i].base, 0, rq->rx_ring[i].size *
+		       sizeof(struct Vmxnet3_RxDesc));
+		rq->rx_ring[i].gen = VMXNET3_INIT_GEN;
+	}
+	if (vmxnet3_rq_alloc_rx_buf(rq, 0, rq->rx_ring[0].size - 1,
+				    adapter) == 0) {
+		/* at least has 1 rx buffer for the 1st ring */
+		return -ENOMEM;
+	}
+	vmxnet3_rq_alloc_rx_buf(rq, 1, rq->rx_ring[1].size - 1, adapter);
+
+	/* reset the comp ring */
+	rq->comp_ring.next2proc = 0;
+	memset(rq->comp_ring.base, 0, rq->comp_ring.size *
+	       sizeof(struct Vmxnet3_RxCompDesc));
+	rq->comp_ring.gen = VMXNET3_INIT_GEN;
+
+	/* reset rxctx */
+	rq->rx_ctx.skb = NULL;
+
+	/* stats are not reset */
+	return 0;
+}
+
+
+/*
+ *    allocate and initialize two cmd rings and the completion ring for the
+ *    given rx queue. Also allocate and initialize buf_info.
+ *    rx buffers are NOT allocated
+ */
+static int
+vmxnet3_rq_create(struct vmxnet3_rx_queue *rq, struct vmxnet3_adapter *adapter)
+{
+	int i;
+	size_t sz;
+	struct vmxnet3_rx_buf_info *bi;
+
+	BUG_ON(rq->rx_ring[0].size % adapter->rx_buf_per_pkt != 0);
+	for (i = 0; i < 2; i++) {
+		BUG_ON((rq->rx_ring[i].size & VMXNET3_RING_SIZE_MASK) != 0);
+		BUG_ON(rq->rx_ring[i].base != NULL);
+		sz = rq->rx_ring[i].size * sizeof(struct Vmxnet3_RxDesc);
+		rq->rx_ring[i].base = pci_alloc_consistent(adapter->pdev, sz,
+							&rq->rx_ring[i].basePA);
+		if (!rq->rx_ring[i].base) {
+			printk(KERN_ERR "%s: failed to allocate rx ring %d\n",
+			       adapter->netdev->name, i);
+			goto err;
+		}
+	}
+
+	sz = rq->comp_ring.size * sizeof(Vmxnet3_RxCompDesc);
+	BUG_ON(rq->comp_ring.base != NULL);
+	rq->comp_ring.base = pci_alloc_consistent(adapter->pdev,
+			sz,
+			&rq->comp_ring.basePA);
+	if (!rq->comp_ring.base) {
+		printk(KERN_ERR "%s: failed to allocate rx comp ring\n",
+		       adapter->netdev->name);
+		goto err;
+	}
+
+	BUG_ON(rq->buf_info[0] || rq->buf_info[1]);
+	sz = sizeof(struct vmxnet3_rx_buf_info) * (rq->rx_ring[0].size +
+						   rq->rx_ring[1].size);
+	bi = kmalloc(sz, GFP_KERNEL);
+	if (!bi) {
+		printk(KERN_ERR "%s: failed to allocate rx bufinfo\n",
+		       adapter->netdev->name);
+		goto err;
+	}
+	memset(bi, 0, sz);
+	rq->buf_info[0] = bi;
+	rq->buf_info[1] = bi + rq->rx_ring[0].size;
+
+	return 0;
+
+err:
+	vmxnet3_rq_destroy(rq, adapter);
+	return -ENOMEM;
+}
+
+#ifdef VMXNET3_NAPI
+
+static int
+vmxnet3_do_poll(struct vmxnet3_adapter *adapter, int budget)
+{
+	if (unlikely(adapter->shared->ecr))
+		vmxnet3_process_events(adapter);
+
+	vmxnet3_tq_tx_complete(&adapter->tx_queue, adapter);
+	return vmxnet3_rq_rx_complete(&adapter->rx_queue, adapter, budget);
+}
+
+
+#ifdef VMXNET3_NEW_NAPI
+
+/*
+ * New NAPI polling function. Returns # of the NAPI credit consumed (# of rx
+ * descriptors processed)
+ */
+static int
+vmxnet3_poll(struct napi_struct *napi, int budget)
+{
+	struct vmxnet3_adapter *adapter = container_of(napi,
+					  struct vmxnet3_adapter, napi);
+	int rxd_done;
+
+	rxd_done = vmxnet3_do_poll(adapter, budget);
+
+	if (rxd_done < budget) {
+		compat_napi_complete(adapter->netdev, napi);
+		vmxnet3_enable_intr(adapter, 0);
+	}
+	return rxd_done;
+}
+#else
+/*
+ * Result:
+ *    0: napi is done
+ *    1: continue polling
+ */
+
+static int
+vmxnet3_poll(struct net_device *poll_dev, int *budget)
+{
+	int rxd_done, quota;
+	struct vmxnet3_adapter *adapter = netdev_priv(poll_dev);
+
+	quota = min(*budget, poll_dev->quota);
+
+	rxd_done = vmxnet3_do_poll(adapter, quota);
+
+	*budget -= rxd_done;
+	poll_dev->quota -= rxd_done;
+
+	if (rxd_done < quota) {
+                compat_napi_complete(poll_dev, NULL);
+		vmxnet3_enable_intr(adapter, 0);
+		return 0;
+	}
+
+	return 1; /* not done */
+}
+
+#endif /* VMXNET3_NEW_NAPI  */
+#endif /* VMXNET3_NAPI  */
+
+
+/* Interrupt handler for vmxnet3  */
+static compat_irqreturn_t
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+vmxnet3_intr(int irq, void *dev_id, struct pt_regs * regs)
+#else
+vmxnet3_intr(int irq, void *dev_id)
+#endif
+{
+	struct net_device *dev = dev_id;
+	struct vmxnet3_adapter *adapter = netdev_priv(dev);
+
+	if (unlikely(adapter->intr.type == VMXNET3_IT_INTX)) {
+		u32 icr = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_ICR);
+		if (unlikely(icr == 0))
+			/* not ours */
+			return IRQ_NONE;
+	}
+
+#ifdef VMXNET3_NAPI
+	/* disable intr if needed */
+	if (adapter->intr.mask_mode == VMXNET3_IMM_ACTIVE)
+		vmxnet3_disable_intr(adapter, 0);
+
+	compat_napi_schedule(dev, &adapter->napi);
+
+#else
+	vmxnet3_tq_tx_complete(&adapter->tx_queue, adapter);
+	vmxnet3_rq_rx_complete(&adapter->rx_queue, adapter);
+	if (unlikely(adapter->shared->ecr)) {
+		vmxnet3_process_events(adapter);
+	}
+	vmxnet3_enable_intr(adapter, 0);
+#endif
+
+	return COMPAT_IRQ_HANDLED;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+
+
+static void
+vmxnet3_netpoll(struct net_device *netdev)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+	int irq;
+
+#ifdef CONFIG_PCI_MSI
+	if (adapter->intr.type == VMXNET3_IT_MSIX)
+		irq = adapter->intr.msix_entries[0].vector;
+	else
+#endif
+		irq = adapter->pdev->irq;
+
+	disable_irq(irq);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+	vmxnet3_intr(irq, netdev, NULL);
+#else
+	vmxnet3_intr(irq, netdev);
+#endif
+	enable_irq(irq);
+}
+#endif
+
+
+/*
+ * event_intr_idx and intr_idx for different comp rings get updated here.
+ */
+
+static int
+vmxnet3_request_irqs(struct vmxnet3_adapter *adapter)
+{
+	int err;
+
+#ifdef CONFIG_PCI_MSI
+	if (adapter->intr.type == VMXNET3_IT_MSIX)
+		/* we only use 1 MSI-X vector */
+		err = request_irq(adapter->intr.msix_entries[0].vector,
+				  vmxnet3_intr, 0, adapter->netdev->name,
+				  adapter->netdev);
+	else if (adapter->intr.type == VMXNET3_IT_MSI)
+		err = request_irq(adapter->pdev->irq, vmxnet3_intr, 0,
+				  adapter->netdev->name, adapter->netdev);
+	else
+#endif
+		err = request_irq(adapter->pdev->irq, vmxnet3_intr,
+				  COMPAT_IRQF_SHARED, adapter->netdev->name,
+				  adapter->netdev);
+
+	if (err)
+		printk(KERN_ERR "Failed to request irq %s (intr type:%d), error"
+		       ":%d\n", adapter->netdev->name, adapter->intr.type, err);
+
+
+	if (!err) {
+		int i;
+		/* init our intr settings */
+		for (i = 0; i < adapter->intr.num_intrs; i++)
+			adapter->intr.mod_levels[i] = UPT1_IML_ADAPTIVE;
+
+		/* next setup intr index for all intr sources */
+		adapter->tx_queue.comp_ring.intr_idx = 0;
+		adapter->rx_queue.comp_ring.intr_idx = 0;
+		adapter->intr.event_intr_idx = 0;
+
+		printk(KERN_INFO "%s: intr type %u, mode %u, %u vectors "
+		       "allocated\n", adapter->netdev->name, adapter->intr.type,
+		       adapter->intr.mask_mode, adapter->intr.num_intrs);
+	}
+
+	return err;
+}
+
+
+static void
+vmxnet3_free_irqs(struct vmxnet3_adapter *adapter)
+{
+	BUG_ON(adapter->intr.type == VMXNET3_IT_AUTO ||
+	       adapter->intr.num_intrs <= 0);
+
+	switch (adapter->intr.type) {
+#ifdef CONFIG_PCI_MSI
+	case VMXNET3_IT_MSIX:
+	{
+		int i;
+
+		for (i = 0; i < adapter->intr.num_intrs; i++)
+			free_irq(adapter->intr.msix_entries[i].vector,
+				 adapter->netdev);
+		break;
+	}
+	case VMXNET3_IT_MSI:
+		free_irq(adapter->pdev->irq, adapter->netdev);
+		break;
+#endif
+	case VMXNET3_IT_INTX:
+		free_irq(adapter->pdev->irq, adapter->netdev);
+		break;
+	default:
+		BUG_ON(TRUE);
+	}
+}
+
+
+static void
+vmxnet3_vlan_rx_register(struct net_device *netdev, struct vlan_group *grp)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+	struct Vmxnet3_DriverShared *shared = adapter->shared;
+	u32 *vfTable = adapter->shared->devRead.rxFilterConf.vfTable;
+
+	if (grp) {
+		/* add vlan rx stripping. */
+		if (adapter->netdev->features & NETIF_F_HW_VLAN_RX) {
+			int i;
+			struct Vmxnet3_DSDevRead *devRead = &shared->devRead;
+			adapter->vlan_grp = grp;
+
+			/* update FEATURES to device */
+			set_flag_le64(&devRead->misc.uptFeatures,
+				      UPT1_F_RXVLAN);
+			VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,
+					       VMXNET3_CMD_UPDATE_FEATURE);
+			/*
+			 *  Clear entire vfTable; then enable untagged pkts.
+			 *  Note: setting one entry in vfTable to non-zero turns
+			 *  on VLAN rx filtering.
+			 */
+			for (i = 0; i < VMXNET3_VFT_SIZE; i++)
+				vfTable[i] = 0;
+
+			VMXNET3_SET_VFTABLE_ENTRY(vfTable, 0);
+			VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,
+					       VMXNET3_CMD_UPDATE_VLAN_FILTERS);
+		} else {
+			printk(KERN_ERR "%s: vlan_rx_register when device has "
+			       "no NETIF_F_HW_VLAN_RX\n", netdev->name);
+		}
+	} else {
+		/* remove vlan rx stripping. */
+		struct Vmxnet3_DSDevRead *devRead = &shared->devRead;
+		adapter->vlan_grp = NULL;
+
+		if (le64_to_cpu(devRead->misc.uptFeatures) & UPT1_F_RXVLAN) {
+			int i;
+
+			for (i = 0; i < VMXNET3_VFT_SIZE; i++) {
+				/* clear entire vfTable; this also disables
+				 * VLAN rx filtering
+				 */
+				vfTable[i] = 0;
+			}
+			VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,
+					       VMXNET3_CMD_UPDATE_VLAN_FILTERS);
+
+			/* update FEATURES to device */
+			reset_flag_le64(&devRead->misc.uptFeatures,
+					UPT1_F_RXVLAN);
+			VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,
+					       VMXNET3_CMD_UPDATE_FEATURE);
+		}
+	}
+}
+
+
+static void
+vmxnet3_restore_vlan(struct vmxnet3_adapter *adapter)
+{
+	if (adapter->vlan_grp) {
+		u16 vid;
+		u32 *vfTable = adapter->shared->devRead.rxFilterConf.vfTable;
+		Bool activeVlan = FALSE;
+
+		for (vid = 0; vid < VLAN_GROUP_ARRAY_LEN; vid++) {
+			if (compat_vlan_group_get_device(adapter->vlan_grp,
+							 vid)) {
+				VMXNET3_SET_VFTABLE_ENTRY(vfTable, vid);
+				activeVlan = TRUE;
+			}
+		}
+		if (activeVlan) {
+			/* continue to allow untagged pkts */
+			VMXNET3_SET_VFTABLE_ENTRY(vfTable, 0);
+		}
+	}
+}
+
+/* Inherit net_device features from real device to VLAN device. */
+void
+vmxnet3_vlan_features(struct vmxnet3_adapter *adapter, u16 vid, Bool allvids)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+	struct net_device *v_netdev;
+
+	if (adapter->vlan_grp) {
+		if (allvids) {
+			for (vid = 0; vid < VLAN_GROUP_ARRAY_LEN; vid++) {
+				v_netdev = compat_vlan_group_get_device(
+							adapter->vlan_grp, vid);
+				if (v_netdev) {
+					v_netdev->features |=
+						      adapter->netdev->features;
+					compat_vlan_group_set_device(
+					      adapter->vlan_grp, vid, v_netdev);
+				}
+			}
+		} else {
+			v_netdev = compat_vlan_group_get_device(
+							adapter->vlan_grp, vid);
+			if (v_netdev) {
+				v_netdev->features |= adapter->netdev->features;
+				compat_vlan_group_set_device(adapter->vlan_grp,
+							     vid, v_netdev);
+			}
+		}
+	}
+#endif
+}
+
+
+static void
+vmxnet3_vlan_rx_add_vid(struct net_device *netdev, u16 vid)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+	u32 *vfTable = adapter->shared->devRead.rxFilterConf.vfTable;
+
+	vmxnet3_vlan_features(adapter, vid, FALSE);
+	VMXNET3_SET_VFTABLE_ENTRY(vfTable, vid);
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,
+			       VMXNET3_CMD_UPDATE_VLAN_FILTERS);
+}
+
+
+static void
+vmxnet3_vlan_rx_kill_vid(struct net_device *netdev, u16 vid)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+	u32 *vfTable = adapter->shared->devRead.rxFilterConf.vfTable;
+
+	VMXNET3_CLEAR_VFTABLE_ENTRY(vfTable, vid);
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,
+			       VMXNET3_CMD_UPDATE_VLAN_FILTERS);
+}
+
+
+/*
+ * Allocate a buffer and copy into the mcast list. Returns NULL if the mcast
+ * list exceeds the limit. Returns the addr of the allocated buffer or NULL.
+ */
+
+static u8 *
+vmxnet3_copy_mc(struct net_device *netdev)
+{
+	u8 *buf = NULL;
+	u32 sz = netdev->mc_count * ETH_ALEN;
+
+	/* Vmxnet3_RxFilterConf.mfTableLen is u16. */
+	if (sz <= 0xffff) {
+		/* We may be called with BH disabled */
+		buf = kmalloc(sz, GFP_ATOMIC);
+		if (buf) {
+			int i;
+			struct dev_mc_list *mc = netdev->mc_list;
+
+			for (i = 0; i < netdev->mc_count; i++) {
+				BUG_ON(!mc);
+				memcpy(buf + i * ETH_ALEN, mc->dmi_addr,
+				       ETH_ALEN);
+				mc = mc->next;
+			}
+		}
+	}
+	return buf;
+}
+
+
+static void
+vmxnet3_set_mc(struct net_device *netdev)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+	struct Vmxnet3_RxFilterConf *rxConf =
+					&adapter->shared->devRead.rxFilterConf;
+	u8 *new_table = NULL;
+	u32 new_mode = VMXNET3_RXM_UCAST;
+
+	if (netdev->flags & IFF_PROMISC)
+		new_mode |= VMXNET3_RXM_PROMISC;
+
+	if (netdev->flags & IFF_BROADCAST)
+		new_mode |= VMXNET3_RXM_BCAST;
+
+	if (netdev->flags & IFF_ALLMULTI)
+		new_mode |= VMXNET3_RXM_ALL_MULTI;
+	else if (netdev->mc_count > 0) {
+		new_table = vmxnet3_copy_mc(netdev);
+		if (new_table) {
+			new_mode |= VMXNET3_RXM_MCAST;
+			rxConf->mfTableLen = cpu_to_le16(
+					netdev->mc_count * ETH_ALEN);
+			rxConf->mfTablePA = cpu_to_le64(virt_to_phys(
+					    new_table));
+		} else {
+			printk(KERN_INFO "%s: failed to copy mcast list, "
+			       "setting ALL_MULTI\n", netdev->name);
+			new_mode |= VMXNET3_RXM_ALL_MULTI;
+		}
+	}
+
+
+	if (!(new_mode & VMXNET3_RXM_MCAST)) {
+		rxConf->mfTableLen = 0;
+		rxConf->mfTablePA = 0;
+	}
+
+	if (new_mode != rxConf->rxMode) {
+		rxConf->rxMode = cpu_to_le32(new_mode);
+		VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,
+				       VMXNET3_CMD_UPDATE_RX_MODE);
+	}
+
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,
+			       VMXNET3_CMD_UPDATE_MAC_FILTERS);
+
+	kfree(new_table);
+}
+
+
+/*
+ * Wipes out the whole driver_shared area and re-initializes it
+ */
+
+static void
+vmxnet3_setup_driver_shared(struct vmxnet3_adapter *adapter)
+{
+	struct Vmxnet3_DriverShared *shared = adapter->shared;
+	struct Vmxnet3_DSDevRead *devRead = &shared->devRead;
+	struct Vmxnet3_TxQueueConf *tqc;
+	struct Vmxnet3_RxQueueConf *rqc;
+	int i;
+
+	memset(shared, 0, sizeof(*shared));
+
+	/* driver settings */
+	shared->magic = cpu_to_le32(VMXNET3_REV1_MAGIC);
+	devRead->misc.driverInfo.version = cpu_to_le32(
+						VMXNET3_DRIVER_VERSION_NUM);
+	devRead->misc.driverInfo.gos.gosBits = (sizeof(void *) == 4 ?
+				VMXNET3_GOS_BITS_32 : VMXNET3_GOS_BITS_64);
+	devRead->misc.driverInfo.gos.gosType = VMXNET3_GOS_TYPE_LINUX;
+	*((u32 *)&devRead->misc.driverInfo.gos) = cpu_to_le32(
+				*((u32 *)&devRead->misc.driverInfo.gos));
+	devRead->misc.driverInfo.vmxnet3RevSpt = cpu_to_le32(1);
+	devRead->misc.driverInfo.uptVerSpt = cpu_to_le32(1);
+
+	devRead->misc.ddPA = cpu_to_le64(virt_to_phys(adapter));
+	devRead->misc.ddLen = cpu_to_le32(sizeof(struct vmxnet3_adapter));
+
+	/* set up feature flags */
+	if (adapter->rxcsum)
+		set_flag_le64(&devRead->misc.uptFeatures, UPT1_F_RXCSUM);
+
+	if (adapter->lro) {
+		set_flag_le64(&devRead->misc.uptFeatures, UPT1_F_LRO);
+		devRead->misc.maxNumRxSG = cpu_to_le16(1 + MAX_SKB_FRAGS);
+	}
+	if ((adapter->netdev->features & NETIF_F_HW_VLAN_RX)
+			&& adapter->vlan_grp) {
+		set_flag_le64(&devRead->misc.uptFeatures, UPT1_F_RXVLAN);
+	}
+
+	devRead->misc.mtu = cpu_to_le32(adapter->netdev->mtu);
+	devRead->misc.queueDescPA = cpu_to_le64(adapter->queue_desc_pa);
+	devRead->misc.queueDescLen = cpu_to_le32(
+				     sizeof(struct Vmxnet3_TxQueueDesc) +
+				     sizeof(struct Vmxnet3_RxQueueDesc));
+
+	/* tx queue settings */
+	BUG_ON(adapter->tx_queue.tx_ring.base == NULL);
+
+	devRead->misc.numTxQueues = 1;
+	tqc = &adapter->tqd_start->conf;
+	tqc->txRingBasePA   = cpu_to_le64(adapter->tx_queue.tx_ring.basePA);
+	tqc->dataRingBasePA = cpu_to_le64(adapter->tx_queue.data_ring.basePA);
+	tqc->compRingBasePA = cpu_to_le64(adapter->tx_queue.comp_ring.basePA);
+	tqc->ddPA           = cpu_to_le64(virt_to_phys(
+						adapter->tx_queue.buf_info));
+	tqc->txRingSize     = cpu_to_le32(adapter->tx_queue.tx_ring.size);
+	tqc->dataRingSize   = cpu_to_le32(adapter->tx_queue.data_ring.size);
+	tqc->compRingSize   = cpu_to_le32(adapter->tx_queue.comp_ring.size);
+	tqc->ddLen          = cpu_to_le32(sizeof(struct vmxnet3_tx_buf_info) *
+			      tqc->txRingSize);
+	tqc->intrIdx        = adapter->tx_queue.comp_ring.intr_idx;
+
+	/* rx queue settings */
+	devRead->misc.numRxQueues = 1;
+	rqc = &adapter->rqd_start->conf;
+	rqc->rxRingBasePA[0] = cpu_to_le64(adapter->rx_queue.rx_ring[0].basePA);
+	rqc->rxRingBasePA[1] = cpu_to_le64(adapter->rx_queue.rx_ring[1].basePA);
+	rqc->compRingBasePA  = cpu_to_le64(adapter->rx_queue.comp_ring.basePA);
+	rqc->ddPA            = cpu_to_le64(virt_to_phys(
+						adapter->rx_queue.buf_info));
+	rqc->rxRingSize[0]   = cpu_to_le32(adapter->rx_queue.rx_ring[0].size);
+	rqc->rxRingSize[1]   = cpu_to_le32(adapter->rx_queue.rx_ring[1].size);
+	rqc->compRingSize    = cpu_to_le32(adapter->rx_queue.comp_ring.size);
+	rqc->ddLen           = cpu_to_le32(sizeof(struct vmxnet3_rx_buf_info) *
+			       (rqc->rxRingSize[0] + rqc->rxRingSize[1]));
+	rqc->intrIdx         = adapter->rx_queue.comp_ring.intr_idx;
+
+	/* intr settings */
+	devRead->intrConf.autoMask = adapter->intr.mask_mode ==
+				     VMXNET3_IMM_AUTO;
+	devRead->intrConf.numIntrs = adapter->intr.num_intrs;
+	for (i = 0; i < adapter->intr.num_intrs; i++)
+		devRead->intrConf.modLevels[i] = adapter->intr.mod_levels[i];
+
+	devRead->intrConf.eventIntrIdx = adapter->intr.event_intr_idx;
+
+	/* rx filter settings */
+	devRead->rxFilterConf.rxMode = 0;
+	vmxnet3_restore_vlan(adapter);
+	/* the rest are already zeroed */
+}
+
+/*
+ * put the vNIC into an operational state. After this function finishes, the
+ * adapter is fully functional. It does the following:
+ * 1. initialize tq and rq
+ * 2. fill rx rings with rx buffers
+ * 3. setup intr
+ * 4. setup driver_shared
+ * 5. activate the dev
+ * 6. signal the stack that the vNIC is ready to tx/rx
+ * 7. enable intrs for the vNIC
+ *
+ * Returns:
+ *    0 if the vNIC is in operation state
+ *    error code if any intermediate step fails.
+ */
+
+int
+vmxnet3_activate_dev(struct vmxnet3_adapter *adapter)
+{
+	int err;
+	u32 ret;
+
+	dev_dbg(&adapter->pdev->dev, "%s: skb_buf_size %d, rx_buf_per_pkt %d, "
+		"ring sizes %u %u %u\n", adapter->netdev->name,
+		adapter->skb_buf_size, adapter->rx_buf_per_pkt,
+		adapter->tx_queue.tx_ring.size,
+		adapter->rx_queue.rx_ring[0].size,
+		adapter->rx_queue.rx_ring[1].size);
+
+	vmxnet3_tq_init(&adapter->tx_queue, adapter);
+	err = vmxnet3_rq_init(&adapter->rx_queue, adapter);
+	if (err) {
+		printk(KERN_ERR "Failed to init rx queue for %s: error %d\n",
+		       adapter->netdev->name, err);
+		goto rq_err;
+	}
+
+	err = vmxnet3_request_irqs(adapter);
+	if (err) {
+		printk(KERN_ERR "Failed to setup irq for %s: error %d\n",
+		       adapter->netdev->name, err);
+		goto irq_err;
+	}
+
+	vmxnet3_setup_driver_shared(adapter);
+
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DSAL,VMXNET3_GET_ADDR_LO(
+			       adapter->shared_pa));
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DSAH, VMXNET3_GET_ADDR_HI(
+			       adapter->shared_pa));
+
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,
+			       VMXNET3_CMD_ACTIVATE_DEV);
+	ret = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);
+	if (ret != 0) {
+		printk(KERN_ERR "Failed to activate dev %s: error %u\n",
+		       adapter->netdev->name, ret);
+		err = -EINVAL;
+		goto activate_err;
+	}
+	VMXNET3_WRITE_BAR0_REG(adapter, VMXNET3_REG_RXPROD,
+			       adapter->rx_queue.rx_ring[0].next2fill);
+	VMXNET3_WRITE_BAR0_REG(adapter, VMXNET3_REG_RXPROD2,
+			       adapter->rx_queue.rx_ring[1].next2fill);
+
+	/* Apply the rx filter settins last. */
+	vmxnet3_set_mc(adapter->netdev);
+
+	/*
+	 * Check link state when first activating device. It will start the
+	 * tx queue if the link is up.
+	 */
+	vmxnet3_check_link(adapter);
+#ifdef VMXNET3_NAPI
+	compat_napi_enable(adapter->netdev, &adapter->napi);
+#endif
+	vmxnet3_enable_all_intrs(adapter);
+	clear_bit(VMXNET3_STATE_BIT_QUIESCED, &adapter->state);
+	return 0;
+
+activate_err:
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DSAL, 0);
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DSAH, 0);
+	vmxnet3_free_irqs(adapter);
+irq_err:
+rq_err:
+	/* free up buffers we allocated */
+	vmxnet3_rq_cleanup(&adapter->rx_queue, adapter);
+	return err;
+}
+
+
+void
+vmxnet3_reset_dev(struct vmxnet3_adapter *adapter)
+{
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD, VMXNET3_CMD_RESET_DEV);
+}
+
+
+/*
+ * Stop the device. After this function returns, the adapter stop pkt tx/rx
+ * and won't generate intrs. The stack won't try to xmit pkts through us,
+ * nor will it poll us for pkts. It does the following:
+ *
+ * 1. ask the vNIC to quiesce
+ * 2. disable the vNIC from generating intrs
+ * 3. free intr
+ * 4. stop the stack from xmiting pkts thru us and polling
+ * 5. free rx buffers
+ * 6. tx complete pkts pending
+ *
+ */
+
+int
+vmxnet3_quiesce_dev(struct vmxnet3_adapter *adapter)
+{
+	if (test_and_set_bit(VMXNET3_STATE_BIT_QUIESCED, &adapter->state))
+		return 0;
+
+
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,
+			       VMXNET3_CMD_QUIESCE_DEV);
+	vmxnet3_disable_all_intrs(adapter);
+#ifdef VMXNET3_NAPI
+	compat_napi_disable(adapter->netdev, &adapter->napi);
+#endif
+	netif_tx_disable(adapter->netdev);
+	adapter->link_speed = 0;
+	netif_carrier_off(adapter->netdev);
+
+	vmxnet3_tq_cleanup(&adapter->tx_queue, adapter);
+	vmxnet3_rq_cleanup(&adapter->rx_queue, adapter);
+	vmxnet3_free_irqs(adapter);
+	return 0;
+}
+
+
+static void
+vmxnet3_write_mac_addr(struct vmxnet3_adapter *adapter, u8 *mac)
+{
+	u32 tmp;
+
+	tmp = *(u32 *)mac;
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_MACL, tmp);
+
+	tmp = (mac[5] << 8) | mac[4];
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_MACH, tmp);
+}
+
+
+static int
+vmxnet3_set_mac_addr(struct net_device *netdev, void *p)
+{
+	struct sockaddr *addr = p;
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+
+	memcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);
+	vmxnet3_write_mac_addr(adapter, netdev->dev_addr);
+
+	return 0;
+}
+
+
+/* ==================== initialization and cleanup routines ============ */
+
+static int
+vmxnet3_alloc_pci_resources(struct vmxnet3_adapter *adapter, Bool *dma64)
+{
+	int err;
+	unsigned long mmio_start, mmio_len;
+	struct pci_dev *pdev = adapter->pdev;
+
+	err = compat_pci_enable_device(pdev);
+	if (err) {
+		printk(KERN_ERR "Failed to enable adapter %s: error %d\n",
+		       compat_pci_name(pdev), err);
+		return err;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 6)
+	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) == 0) {
+		if (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64)) != 0) {
+			printk(KERN_ERR "pci_set_consistent_dma_mask failed "
+			       "for adapter %s\n", compat_pci_name(pdev));
+			err = -EIO;
+			goto err_set_mask;
+		}
+		*dma64 = TRUE;
+	} else {
+		if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0) {
+			printk(KERN_ERR "pci_set_dma_mask failed for adapter "
+			       "%s\n",	compat_pci_name(pdev));
+			err = -EIO;
+			goto err_set_mask;
+		}
+		*dma64 = FALSE;
+	}
+#else
+	*dma64 = TRUE;
+#endif
+
+	err = compat_pci_request_regions(pdev, vmxnet3_driver_name);
+	if (err) {
+		printk(KERN_ERR "Failed to request region for adapter %s: "
+		       "error %d\n", compat_pci_name(pdev), err);
+		goto err_set_mask;
+	}
+
+	compat_pci_set_master(pdev);
+
+	mmio_start = compat_pci_resource_start(pdev, 0);
+	mmio_len = compat_pci_resource_len(pdev, 0);
+	adapter->hw_addr0 = ioremap(mmio_start, mmio_len);
+	if (!adapter->hw_addr0) {
+		printk(KERN_ERR "Failed to map bar0 for adapter %s\n",
+		       compat_pci_name(pdev));
+		err = -EIO;
+		goto err_ioremap;
+	}
+
+	mmio_start = compat_pci_resource_start(pdev, 1);
+	mmio_len = compat_pci_resource_len(pdev, 1);
+	adapter->hw_addr1 = ioremap(mmio_start, mmio_len);
+	if (!adapter->hw_addr1) {
+		printk(KERN_ERR "Failed to map bar1 for adapter %s\n",
+		       compat_pci_name(pdev));
+		err = -EIO;
+		goto err_bar1;
+	}
+	return 0;
+
+err_bar1:
+	iounmap(adapter->hw_addr0);
+err_ioremap:
+	compat_pci_release_regions(pdev);
+err_set_mask:
+	compat_pci_disable_device(pdev);
+	return err;
+}
+
+
+static void
+vmxnet3_free_pci_resources(struct vmxnet3_adapter *adapter)
+{
+	BUG_ON(!adapter->pdev);
+
+	iounmap(adapter->hw_addr0);
+	iounmap(adapter->hw_addr1);
+	compat_pci_release_regions(adapter->pdev);
+	compat_pci_disable_device(adapter->pdev);
+}
+
+
+
+/*
+ * Calculate the # of buffers for a pkt based on mtu, then adjust the size of
+ * the 1st rx ring accordingly
+ */
+
+static void
+vmxnet3_adjust_rx_ring_size(struct vmxnet3_adapter *adapter)
+{
+	size_t sz;
+
+	if (adapter->netdev->mtu <= VMXNET3_MAX_SKB_BUF_SIZE -
+				    VMXNET3_MAX_ETH_HDR_SIZE) {
+		adapter->skb_buf_size = adapter->netdev->mtu +
+					VMXNET3_MAX_ETH_HDR_SIZE;
+		if (adapter->skb_buf_size < VMXNET3_MIN_T0_BUF_SIZE)
+			adapter->skb_buf_size = VMXNET3_MIN_T0_BUF_SIZE;
+
+		adapter->rx_buf_per_pkt = 1;
+	} else {
+		adapter->skb_buf_size = VMXNET3_MAX_SKB_BUF_SIZE;
+		sz = adapter->netdev->mtu - VMXNET3_MAX_SKB_BUF_SIZE +
+					    VMXNET3_MAX_ETH_HDR_SIZE;
+		adapter->rx_buf_per_pkt = 1 + (sz + PAGE_SIZE - 1) / PAGE_SIZE;
+	}
+
+	if (adapter->is_shm) {
+		adapter->skb_buf_size = PAGE_SIZE;
+	}
+
+	/*
+	 * for simplicity, force the ring0 size to be a multiple of
+	 * rx_buf_per_pkt * VMXNET3_RING_SIZE_ALIGN
+	 */
+	sz = adapter->rx_buf_per_pkt * VMXNET3_RING_SIZE_ALIGN;
+	adapter->rx_queue.rx_ring[0].size = (adapter->rx_queue.rx_ring[0].size +
+					     sz - 1) / sz * sz;
+	adapter->rx_queue.rx_ring[0].size = min_t(u32,
+					    adapter->rx_queue.rx_ring[0].size,
+					    VMXNET3_RX_RING_MAX_SIZE / sz * sz);
+}
+
+/* Create the specified number of tx queues and rx queues. On failure, it
+ * destroys the queues created. */
+int
+vmxnet3_create_queues(struct vmxnet3_adapter *adapter, u32 tx_ring_size,
+		      u32 rx_ring_size, u32 rx_ring2_size)
+{
+	int err;
+
+	adapter->tx_queue.tx_ring.size   = tx_ring_size;
+	adapter->tx_queue.data_ring.size = tx_ring_size;
+	adapter->tx_queue.comp_ring.size = tx_ring_size;
+	adapter->tx_queue.shared = &adapter->tqd_start->ctrl;
+	adapter->tx_queue.stopped = TRUE;
+	err = vmxnet3_tq_create(&adapter->tx_queue, adapter);
+	if (err)
+		return err;
+
+	adapter->rx_queue.rx_ring[0].size = rx_ring_size;
+	adapter->rx_queue.rx_ring[1].size = rx_ring2_size;
+	vmxnet3_adjust_rx_ring_size(adapter);
+	adapter->rx_queue.comp_ring.size  = adapter->rx_queue.rx_ring[0].size +
+					    adapter->rx_queue.rx_ring[1].size;
+	adapter->rx_queue.qid  = 0;
+	adapter->rx_queue.qid2 = 1;
+	adapter->rx_queue.shared = &adapter->rqd_start->ctrl;
+	err = vmxnet3_rq_create(&adapter->rx_queue, adapter);
+	if (err)
+		vmxnet3_tq_destroy(&adapter->tx_queue, adapter);
+
+	return err;
+}
+
+/*
+ * setup rings, allocate necessary resources, request for IRQs, configure
+ * the device. The device is functional after this function finishes
+ * successfully.
+ * Returns 0 on success, negative errno value on failure
+ */
+
+static int
+vmxnet3_open(struct net_device *netdev)
+{
+	struct vmxnet3_adapter *adapter;
+	int err;
+
+	adapter = compat_netdev_priv(netdev);
+
+	spin_lock_init(&adapter->tx_queue.tx_lock);
+
+	if (adapter->is_shm) {
+		printk(KERN_INFO "bringing up shared memory vmxnet3 %s\n",
+		       netdev->name);
+		err = vmxnet3_shm_open(adapter, netdev->name, shm_pool_size);
+		if (err) {
+			goto shm_err;
+		}
+	}
+	err = vmxnet3_create_queues(adapter, VMXNET3_DEF_TX_RING_SIZE,
+				    VMXNET3_DEF_RX_RING_SIZE,
+				    VMXNET3_DEF_RX_RING_SIZE);
+	if (err)
+		goto queue_err;
+
+	err = vmxnet3_activate_dev(adapter);
+	if (err)
+		goto activate_err;
+
+	COMPAT_NETDEV_MOD_INC_USE_COUNT;
+
+	return 0;
+
+activate_err:
+	vmxnet3_rq_destroy(&adapter->rx_queue, adapter);
+	vmxnet3_tq_destroy(&adapter->tx_queue, adapter);
+queue_err:
+	if (adapter->is_shm) {
+		vmxnet3_shm_close(adapter);
+	}
+shm_err:
+	return err;
+}
+
+
+static int
+vmxnet3_close(struct net_device *netdev)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+
+	/*
+	 * Reset_work may be in the middle of resetting the device, wait for its
+	 * completion.
+	 */
+	while (test_and_set_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state))
+		compat_msleep(1);
+
+	vmxnet3_quiesce_dev(adapter);
+
+	if (adapter->is_shm) {
+		vmxnet3_shm_close(adapter);
+	}
+
+	vmxnet3_rq_destroy(&adapter->rx_queue, adapter);
+	vmxnet3_tq_destroy(&adapter->tx_queue, adapter);
+
+	COMPAT_NETDEV_MOD_DEC_USE_COUNT;
+
+	clear_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state);
+
+
+	return 0;
+}
+
+
+/*
+ * Called to forcibly close the device when the driver failed to re-activate it.
+ */
+void
+vmxnet3_force_close(struct vmxnet3_adapter *adapter)
+{
+	/*
+	 * we must clear VMXNET3_STATE_BIT_RESETTING, otherwise
+	 * vmxnet3_close() will deadlock.
+	 */
+	BUG_ON(test_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state));
+
+#ifdef VMXNET3_NAPI
+	/* we need to enable NAPI, otherwise dev_close will deadlock */
+	compat_napi_enable(adapter->netdev, &adapter->napi);
+#endif
+	dev_close(adapter->netdev);
+}
+
+
+static int
+vmxnet3_change_mtu(struct net_device *netdev, int new_mtu)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+	int err = 0;
+
+	if (new_mtu < VMXNET3_MIN_MTU || new_mtu > VMXNET3_MAX_MTU)
+		return -EINVAL;
+
+	if (new_mtu > 1500 && !adapter->jumbo_frame)
+		return -EINVAL;
+
+	netdev->mtu = new_mtu;
+
+	/*
+	 * Reset_work may be in the middle of resetting the device, wait for its
+	 * completion.
+	 */
+	while (test_and_set_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state))
+		compat_msleep(1);
+
+	if (compat_netif_running(netdev)) {
+		vmxnet3_quiesce_dev(adapter);
+		vmxnet3_reset_dev(adapter);
+
+		/* we need to re-create the rx queue based on the new mtu */
+		vmxnet3_rq_destroy(&adapter->rx_queue, adapter);
+		vmxnet3_adjust_rx_ring_size(adapter);
+		adapter->rx_queue.comp_ring.size  =
+					adapter->rx_queue.rx_ring[0].size +
+					adapter->rx_queue.rx_ring[1].size;
+		err = vmxnet3_rq_create(&adapter->rx_queue, adapter);
+		if (err) {
+			printk(KERN_ERR "%s: failed to re-create rx queue,"
+				" error %d. Closing it.\n", netdev->name, err);
+			goto out;
+		}
+
+		err = vmxnet3_activate_dev(adapter);
+		if (err) {
+			printk(KERN_ERR "%s: failed to re-activate, error %d. "
+				"Closing it\n", netdev->name, err);
+			goto out;
+		}
+	}
+
+out:
+	clear_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state);
+	if (err)
+		vmxnet3_force_close(adapter);
+
+	return err;
+}
+
+
+static void
+vmxnet3_declare_features(struct vmxnet3_adapter *adapter, Bool dma64)
+{
+	struct net_device *netdev = adapter->netdev;
+
+	netdev->features = NETIF_F_SG |
+		NETIF_F_HW_CSUM |
+		NETIF_F_HW_VLAN_TX |
+		NETIF_F_HW_VLAN_RX |
+		NETIF_F_HW_VLAN_FILTER |
+		NETIF_F_TSO;
+	printk(KERN_INFO "features: sg csum vlan jf tso");
+
+	adapter->rxcsum = TRUE;
+	adapter->jumbo_frame = TRUE;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+	 /* LRO feature control by module param */
+	if (!disable_lro) {
+#else
+	 /* LRO feature control by ethtool */
+		netdev->features |= NETIF_F_LRO;
+#endif
+
+		adapter->lro = TRUE;
+		printk(" lro");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+	}
+#endif
+
+#ifdef NETIF_F_TSO6
+	netdev->features |= NETIF_F_TSO6;
+	printk(" tsoIPv6");
+#endif
+
+	if (dma64) {
+		netdev->features |= NETIF_F_HIGHDMA;
+		printk(" highDMA");
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+	netdev->vlan_features = netdev->features;
+#endif
+	printk("\n");
+}
+
+
+static void
+vmxnet3_read_mac_addr(struct vmxnet3_adapter *adapter, u8 *mac)
+{
+	u32 tmp;
+
+	tmp = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_MACL);
+	*(u32 *)mac = tmp;
+
+	tmp = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_MACH);
+	mac[4] = tmp & 0xff;
+	mac[5] = (tmp >> 8) & 0xff;
+}
+
+
+
+/*
+ * read the intr configuration, pick the intr type, and enable MSI/MSI-X if
+ * needed. adapter->intr.{type, mask_mode, num_intr} are modified
+ */
+
+static void
+vmxnet3_alloc_intr_resources(struct vmxnet3_adapter *adapter)
+{
+	u32 cfg;
+
+	/* intr settings */
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,
+			       VMXNET3_CMD_GET_CONF_INTR);
+	cfg = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);
+	adapter->intr.type = cfg & 0x3;
+	adapter->intr.mask_mode = (cfg >> 2) & 0x3;
+
+#ifdef CONFIG_PCI_MSI
+	if (adapter->intr.type == VMXNET3_IT_AUTO) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+		/* start with MSI-X */
+		adapter->intr.type = VMXNET3_IT_MSIX;
+		adapter->intr.msix_entries[0].entry = 0;
+		if (!pci_enable_msix(adapter->pdev, adapter->intr.msix_entries,
+				     VMXNET3_LINUX_MAX_MSIX_VECT)) {
+			adapter->intr.num_intrs = 1;
+			return;
+		}
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
+		adapter->intr.type = VMXNET3_IT_MSI;
+		if (!pci_enable_msi(adapter->pdev)) {
+			adapter->intr.num_intrs = 1;
+			return;
+		}
+#endif
+	}
+#endif
+	adapter->intr.type = VMXNET3_IT_INTX;
+
+	/* INT-X related setting */
+	adapter->intr.num_intrs = 1;
+}
+
+
+static void
+vmxnet3_free_intr_resources(struct vmxnet3_adapter *adapter)
+{
+#ifdef CONFIG_PCI_MSI
+	if (adapter->intr.type == VMXNET3_IT_MSIX)
+		pci_disable_msix(adapter->pdev);
+	else if (adapter->intr.type == VMXNET3_IT_MSI)
+		pci_disable_msi(adapter->pdev);
+	else
+#endif
+	{
+		BUG_ON(adapter->intr.type != VMXNET3_IT_INTX);
+	}
+
+}
+
+
+/*
+ * Called when the stack detects a Tx hang. Schedule a job to reset the device
+ */
+
+static void
+vmxnet3_tx_timeout(struct net_device *netdev)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+	adapter->tx_timeout_count++;
+
+	printk(KERN_ERR "%s: tx hang\n", adapter->netdev->name);
+	compat_schedule_work(&adapter->work);
+}
+
+
+static void
+vmxnet3_reset_work(compat_work_arg data)
+{
+	struct vmxnet3_adapter *adapter;
+
+	adapter = COMPAT_WORK_GET_DATA(data, struct vmxnet3_adapter, work);
+
+	/* if another thread is resetting the device, no need to proceed */
+	if (test_and_set_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state))
+		return;
+
+	/* if the device is closed, we must leave it alone */
+	if (netif_running(adapter->netdev)) {
+		printk(KERN_INFO "%s: resetting\n", adapter->netdev->name);
+
+		vmxnet3_quiesce_dev(adapter);
+		vmxnet3_reset_dev(adapter);
+		vmxnet3_activate_dev(adapter);
+	} else {
+		printk(KERN_INFO "%s: already closed\n", adapter->netdev->name);
+	}
+
+	clear_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state);
+}
+
+
+/*
+ * Initialize a vmxnet3 device. Returns 0 on success, negative errno code
+ * otherwise. Initialize the h/w and allocate necessary resources
+ */
+
+static int __devinit
+vmxnet3_probe_device(struct pci_dev *pdev,
+		     const struct pci_device_id *id)
+{
+#ifdef HAVE_NET_DEVICE_OPS
+	static const struct net_device_ops vmxnet3_netdev_ops = {
+		.ndo_open = vmxnet3_open,
+		.ndo_stop = vmxnet3_close,
+		.ndo_start_xmit = vmxnet3_xmit_frame,
+		.ndo_set_mac_address = vmxnet3_set_mac_addr,
+		.ndo_change_mtu = vmxnet3_change_mtu,
+		.ndo_get_stats = vmxnet3_get_stats,
+		.ndo_tx_timeout = vmxnet3_tx_timeout,
+		.ndo_set_multicast_list = vmxnet3_set_mc,
+		.ndo_vlan_rx_register = vmxnet3_vlan_rx_register,
+		.ndo_vlan_rx_add_vid = vmxnet3_vlan_rx_add_vid,
+		.ndo_vlan_rx_kill_vid = vmxnet3_vlan_rx_kill_vid,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+		.ndo_poll_controller = vmxnet3_netpoll,
+#endif
+	};
+#endif	/* HAVE_NET_DEVICE_OPS  */
+	int err;
+	Bool dma64 = FALSE; /* stupid gcc */
+	u32 ver;
+	struct net_device *netdev;
+	struct vmxnet3_adapter *adapter;
+	u8 mac[ETH_ALEN];
+
+	netdev = compat_alloc_etherdev(sizeof(struct vmxnet3_adapter));
+	if (!netdev) {
+		printk(KERN_ERR "Failed to alloc ethernet device %s\n",
+				compat_pci_name(pdev));
+		return -ENOMEM;
+	}
+
+	pci_set_drvdata(pdev, netdev);
+	adapter = compat_netdev_priv(netdev);
+	adapter->netdev = netdev;
+	adapter->pdev = pdev;
+
+	adapter->shared = pci_alloc_consistent(adapter->pdev,
+			  sizeof(struct Vmxnet3_DriverShared),
+			  &adapter->shared_pa);
+	if (!adapter->shared) {
+		printk(KERN_ERR "Failed to allocate memory for %s\n",
+			compat_pci_name(pdev));
+		err = -ENOMEM;
+		goto err_alloc_shared;
+	}
+
+	adapter->tqd_start = pci_alloc_consistent(adapter->pdev,
+			     sizeof(struct Vmxnet3_TxQueueDesc) +
+			     sizeof(struct Vmxnet3_RxQueueDesc),
+			     &adapter->queue_desc_pa);
+
+	if (!adapter->tqd_start) {
+		printk(KERN_ERR "Failed to allocate memory for %s\n",
+			compat_pci_name(pdev));
+		err = -ENOMEM;
+		goto err_alloc_queue_desc;
+	}
+	adapter->rqd_start = (struct Vmxnet3_RxQueueDesc *)(adapter->tqd_start
+							    + 1);
+
+	adapter->pm_conf = kmalloc(sizeof(struct Vmxnet3_PMConf), GFP_KERNEL);
+	if (adapter->pm_conf == NULL) {
+		printk(KERN_ERR "Failed to allocate memory for %s\n",
+			compat_pci_name(pdev));
+		err = -ENOMEM;
+		goto err_alloc_pm;
+	}
+
+	err = vmxnet3_alloc_pci_resources(adapter, &dma64);
+	if (err < 0)
+		goto err_alloc_pci;
+
+	ver = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_VRRS);
+	if (ver & 1) {
+		VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_VRRS, 1);
+	} else {
+		printk(KERN_ERR "Incompatible h/w version (0x%x) for adapter"
+		       " %s\n",	ver, compat_pci_name(pdev));
+		err = -EBUSY;
+		goto err_ver;
+	}
+
+	ver = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_UVRS);
+	if (ver & 1) {
+		VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_UVRS, 1);
+	} else {
+		printk(KERN_ERR "Incompatible upt version (0x%x) for "
+		       "adapter %s\n", ver, compat_pci_name(pdev));
+		err = -EBUSY;
+		goto err_ver;
+	}
+
+	vmxnet3_declare_features(adapter, dma64);
+
+	adapter->dev_number = atomic_read(&devices_found);
+	adapter->is_shm = FALSE;
+	if (adapter->dev_number < VMXNET3_SHM_MAX_DEVICES) {
+		if (enable_shm[adapter->dev_number] == 1) {
+			if (!correct_shm_disclaimer) {
+				printk(KERN_ERR "Did not activate shm, "
+				       "disclaimer missing\n");
+			} else {
+				adapter->is_shm = TRUE;
+			}
+		}
+	}
+
+	vmxnet3_alloc_intr_resources(adapter);
+
+	vmxnet3_read_mac_addr(adapter, mac);
+	memcpy(netdev->dev_addr,  mac, netdev->addr_len);
+
+#ifdef HAVE_NET_DEVICE_OPS
+	netdev->netdev_ops = &vmxnet3_netdev_ops;
+#else
+	netdev->open  = vmxnet3_open;
+	netdev->stop  = vmxnet3_close;
+	netdev->hard_start_xmit = vmxnet3_xmit_frame;
+	netdev->set_mac_address = vmxnet3_set_mac_addr;
+	netdev->change_mtu = vmxnet3_change_mtu;
+	netdev->get_stats = vmxnet3_get_stats;
+	netdev->tx_timeout = vmxnet3_tx_timeout;
+	netdev->set_multicast_list = vmxnet3_set_mc;
+	netdev->vlan_rx_register = vmxnet3_vlan_rx_register;
+	netdev->vlan_rx_add_vid  = vmxnet3_vlan_rx_add_vid;
+	netdev->vlan_rx_kill_vid = vmxnet3_vlan_rx_kill_vid;
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	netdev->poll_controller  = vmxnet3_netpoll;
+#endif
+#endif /* HAVE_NET_DEVICE_OPS  */
+	netdev->watchdog_timeo = 5 * HZ;
+	vmxnet3_set_ethtool_ops(netdev);
+
+	COMPAT_INIT_WORK(&adapter->work, vmxnet3_reset_work, adapter);
+
+#ifdef VMXNET3_NAPI
+	compat_netif_napi_add(netdev, &adapter->napi, vmxnet3_poll, 64);
+#endif
+
+	COMPAT_SET_MODULE_OWNER(netdev);
+	COMPAT_SET_NETDEV_DEV(netdev, &pdev->dev);
+
+	err = register_netdev(netdev);
+	if (err) {
+		printk(KERN_ERR "Failed to register adapter %s\n",
+		       compat_pci_name(pdev));
+		goto err_register;
+	}
+
+	set_bit(VMXNET3_STATE_BIT_QUIESCED, &adapter->state);
+	atomic_inc(&devices_found);
+	return 0;
+
+err_register:
+	vmxnet3_free_intr_resources(adapter);
+err_ver:
+	vmxnet3_free_pci_resources(adapter);
+err_alloc_pci:
+	kfree(adapter->pm_conf);
+err_alloc_pm:
+	pci_free_consistent(adapter->pdev, sizeof(struct Vmxnet3_TxQueueDesc) +
+			    sizeof(struct Vmxnet3_RxQueueDesc),
+			    adapter->tqd_start, adapter->queue_desc_pa);
+err_alloc_queue_desc:
+	pci_free_consistent(adapter->pdev, sizeof(struct Vmxnet3_DriverShared),
+			    adapter->shared, adapter->shared_pa);
+err_alloc_shared:
+	pci_set_drvdata(pdev, NULL);
+	compat_free_netdev(netdev);
+	return err;
+}
+
+
+static void __devexit
+vmxnet3_remove_device(struct pci_dev *pdev)
+{
+	struct net_device *netdev = pci_get_drvdata(pdev);
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+
+	flush_scheduled_work();
+
+	unregister_netdev(netdev);
+
+	vmxnet3_free_intr_resources(adapter);
+	vmxnet3_free_pci_resources(adapter);
+	kfree(adapter->pm_conf);
+	pci_free_consistent(adapter->pdev, sizeof(struct Vmxnet3_TxQueueDesc) +
+			    sizeof(struct Vmxnet3_RxQueueDesc),
+			    adapter->tqd_start, adapter->queue_desc_pa);
+	pci_free_consistent(adapter->pdev, sizeof(struct Vmxnet3_DriverShared),
+			    adapter->shared, adapter->shared_pa);
+	compat_free_netdev(netdev);
+}
+
+
+#ifdef CONFIG_PM
+
+/*
+ *      May programs the wake-up filters if configured to do so.
+ */
+
+static int
+vmxnet3_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+	struct net_device *netdev = pci_get_drvdata(pdev);
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+	struct Vmxnet3_PMConf *pmConf;
+	struct ethhdr *ehdr;
+	struct arphdr *ahdr;
+	u8 *arpreq;
+	struct in_device *in_dev;
+	struct in_ifaddr *ifa;
+	int i = 0;
+
+	if (!compat_netif_running(netdev))
+		return 0;
+
+	vmxnet3_disable_all_intrs(adapter);
+	vmxnet3_free_irqs(adapter);
+	vmxnet3_free_intr_resources(adapter);
+	netif_device_detach(netdev);
+	netif_stop_queue(netdev);
+
+	/* Create wake-up filters. */
+	pmConf = adapter->pm_conf;
+	memset(pmConf, 0, sizeof(*pmConf));
+
+	if (adapter->wol & WAKE_UCAST) {
+		pmConf->filters[i].patternSize = ETH_ALEN;
+		pmConf->filters[i].maskSize = 1;
+		memcpy(pmConf->filters[i].pattern, netdev->dev_addr, ETH_ALEN);
+		pmConf->filters[i].mask[0] = 0x3F; /* LSB ETH_ALEN bits */
+
+		set_flag_le16(&pmConf->wakeUpEvents, VMXNET3_PM_WAKEUP_FILTER);
+		i++;
+	}
+
+	if (adapter->wol & WAKE_ARP) {
+		in_dev = in_dev_get(netdev);
+		if (!in_dev)
+			goto skip_arp;
+
+		ifa = (struct in_ifaddr *)in_dev->ifa_list;
+		if (!ifa) {
+			dev_dbg(&adapter->pdev->dev, "Cannot program WoL ARP"
+				" filter for %s: no IPv4 address.\n",
+				netdev->name);
+			in_dev_put(in_dev);
+			goto skip_arp;
+		}
+		pmConf->filters[i].patternSize = ETH_HLEN + /* Ethernet header */
+			sizeof(struct arphdr) +                  /* ARP header */
+			2 * ETH_ALEN +                           /* 2 Ethernet addresses */
+			2 * sizeof (u32);                     /* 2 IPv4 addresses */
+		pmConf->filters[i].maskSize =
+			(pmConf->filters[i].patternSize - 1) / 8 + 1;
+		/* ETH_P_ARP in Ethernet header. */
+		ehdr = (struct ethhdr *)pmConf->filters[i].pattern;
+		ehdr->h_proto = htons(ETH_P_ARP);
+		/* ARPOP_REQUEST in ARP header. */
+		ahdr = (struct arphdr *)&pmConf->filters[i].pattern[ETH_HLEN];
+		ahdr->ar_op = htons(ARPOP_REQUEST);
+		arpreq = (u8 *)(ahdr + 1);
+
+		/* The Unicast IPv4 address in 'tip' field. */
+		arpreq += 2 * ETH_ALEN + sizeof(u32);
+		*(u32 *)arpreq = ifa->ifa_address;
+
+		/* The mask for the relevant bits. */
+		pmConf->filters[i].mask[0] = 0x00;
+		pmConf->filters[i].mask[1] = 0x30; /* ETH_P_ARP */
+		pmConf->filters[i].mask[2] = 0x30; /* ARPOP_REQUEST */
+		pmConf->filters[i].mask[3] = 0x00;
+		pmConf->filters[i].mask[4] = 0xC0; /* IPv4 TIP */
+		pmConf->filters[i].mask[5] = 0x03; /* IPv4 TIP */
+		in_dev_put(in_dev);
+
+		set_flag_le16(&pmConf->wakeUpEvents, VMXNET3_PM_WAKEUP_FILTER);
+		i++;
+	}
+
+skip_arp:
+	if (adapter->wol & WAKE_MAGIC)
+		set_flag_le16(&pmConf->wakeUpEvents, VMXNET3_PM_WAKEUP_MAGIC);
+
+	pmConf->numFilters = i;
+
+	adapter->shared->devRead.pmConfDesc.confVer = cpu_to_le32(1);
+	adapter->shared->devRead.pmConfDesc.confLen = cpu_to_le32(sizeof(
+								  *pmConf));
+	adapter->shared->devRead.pmConfDesc.confPA = cpu_to_le64(virt_to_phys(
+								 pmConf));
+
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,
+			       VMXNET3_CMD_UPDATE_PMCFG);
+
+	compat_pci_save_state(pdev);
+	pci_enable_wake(pdev, compat_pci_choose_state(pdev, state),
+			adapter->wol);
+	compat_pci_disable_device(pdev);
+	pci_set_power_state(pdev, compat_pci_choose_state(pdev, state));
+
+	return 0;
+}
+
+
+static int
+vmxnet3_resume(struct pci_dev *pdev)
+{
+	int err;
+	struct net_device *netdev = pci_get_drvdata(pdev);
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+	struct Vmxnet3_PMConf *pmConf;
+
+	if (!compat_netif_running(netdev))
+		return 0;
+
+	/* Destroy wake-up filters. */
+	pmConf = adapter->pm_conf;
+	memset(pmConf, 0, sizeof(*pmConf));
+
+	adapter->shared->devRead.pmConfDesc.confVer = cpu_to_le32(1);
+	adapter->shared->devRead.pmConfDesc.confLen = cpu_to_le32(sizeof(
+								  *pmConf));
+	adapter->shared->devRead.pmConfDesc.confPA = cpu_to_le32(virt_to_phys(
+								 pmConf));
+
+	netif_device_attach(netdev);
+	pci_set_power_state(pdev, PCI_D0);
+	compat_pci_restore_state(pdev);
+	err = compat_pci_enable_device(pdev);
+	if (err != 0)
+		return err;
+
+	pci_enable_wake(pdev, PCI_D0, 0);
+
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,
+			       VMXNET3_CMD_UPDATE_PMCFG);
+	vmxnet3_alloc_intr_resources(adapter);
+	vmxnet3_request_irqs(adapter);
+	vmxnet3_enable_all_intrs(adapter);
+
+	return 0;
+}
+
+#endif
+
+static struct pci_driver vmxnet3_driver = {
+	.name		= vmxnet3_driver_name,
+	.id_table	= vmxnet3_pciid_table,
+	.probe		= vmxnet3_probe_device,
+	.remove		= __devexit_p(vmxnet3_remove_device),
+#ifdef CONFIG_PM
+	.suspend	= vmxnet3_suspend,
+	.resume		= vmxnet3_resume,
+#endif
+};
+
+
+static int __init
+vmxnet3_init_module(void)
+{
+	printk(KERN_INFO "%s - version %s\n", VMXNET3_DRIVER_DESC,
+	       VMXNET3_DRIVER_VERSION_REPORT);
+
+	correct_shm_disclaimer = shm_disclaimer &&
+		(strncmp(shm_disclaimer, VMXNET3_SHM_DISCLAIMER,
+		strlen(VMXNET3_SHM_DISCLAIMER)) == 0);
+
+#ifdef CONFIG_COMPAT
+#ifndef HAVE_UNLOCKED_IOCTL
+	if (correct_shm_disclaimer) {
+		register_ioctl32_conversion(SHM_IOCTL_TX, NULL);
+		register_ioctl32_conversion(SHM_IOCTL_ALLOC_ONE, NULL);
+		register_ioctl32_conversion(SHM_IOCTL_ALLOC_MANY, NULL);
+		register_ioctl32_conversion(SHM_IOCTL_ALLOC_ONE_AND_MANY, NULL);
+		register_ioctl32_conversion(SHM_IOCTL_FREE_ONE, NULL);
+	}
+#endif
+#endif
+	return pci_register_driver(&vmxnet3_driver);
+}
+
+module_init(vmxnet3_init_module);
+
+static void
+vmxnet3_exit_module(void)
+{
+#ifdef CONFIG_COMPAT
+#ifndef HAVE_UNLOCKED_IOCTL
+	if (correct_shm_disclaimer) {
+		unregister_ioctl32_conversion(SHM_IOCTL_TX);
+		unregister_ioctl32_conversion(SHM_IOCTL_ALLOC_ONE);
+		unregister_ioctl32_conversion(SHM_IOCTL_ALLOC_MANY);
+		unregister_ioctl32_conversion(SHM_IOCTL_ALLOC_ONE_AND_MANY);
+		unregister_ioctl32_conversion(SHM_IOCTL_FREE_ONE);
+	}
+#endif
+#endif
+	pci_unregister_driver(&vmxnet3_driver);
+}
+
+
+module_exit(vmxnet3_exit_module);
+
+MODULE_AUTHOR("VMware, Inc.");
+MODULE_DESCRIPTION(VMXNET3_DRIVER_DESC);
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION(VMXNET3_DRIVER_VERSION_STRING);
+/*
+ * Starting with SLE10sp2, Novell requires that IHVs sign a support agreement
+ * with them and mark their kernel modules as externally supported via a
+ * change to the module header. If this isn't done, the module will not load
+ * by default (i.e., neither mkinitrd nor modprobe will accept it).
+ */
+MODULE_INFO(supported, "external");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+module_param(disable_lro, int, 0);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 2)
+MODULE_PARM(enable_shm, "0-10i");
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 10)
+module_param_array(enable_shm, int, num_enable_shm, 0);
+#else
+module_param_array(enable_shm, int, &num_enable_shm, 0);
+#endif
+MODULE_PARM_DESC(enable_shm, "Shared memory enable");
+module_param(shm_disclaimer, charp, 0);
+MODULE_PARM_DESC(shm_disclaimer, "Shared memory disclaimer");
+module_param(shm_pool_size, int, 0);
+MODULE_PARM_DESC(shm_pool_size, "Shared memory pool size");
diff -w -N -r -u open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/vmxnet3_ethtool.c open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/vmxnet3_ethtool.c
--- open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/vmxnet3_ethtool.c	1970-01-01 01:00:00.000000000 +0100
+++ open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/vmxnet3_ethtool.c	2009-12-17 22:40:07.000000000 +0100
@@ -0,0 +1,594 @@
+/*********************************************************
+ * Copyright (C) 2007 VMware, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation version 2 and no later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ *
+ *********************************************************/
+
+#include "driver-config.h"
+#include "compat_module.h"
+#include <linux/moduleparam.h>
+#include "vm_basic_types.h"
+#include "vmxnet3_int.h"
+#include <linux/pm.h>
+
+static u32
+vmxnet3_get_rx_csum(struct net_device *netdev)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+	return adapter->rxcsum;
+}
+
+
+static int
+vmxnet3_set_rx_csum(struct net_device *netdev, u32 val)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+
+	if (adapter->rxcsum != val) {
+		adapter->rxcsum = val;
+		if (compat_netif_running(netdev)) {
+			if (val)
+				set_flag_le64(
+				&adapter->shared->devRead.misc.uptFeatures,
+				UPT1_F_RXCSUM);
+			else
+				reset_flag_le64(
+				&adapter->shared->devRead.misc.uptFeatures,
+				UPT1_F_RXCSUM);
+
+			VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,
+					       VMXNET3_CMD_UPDATE_FEATURE);
+		}
+	}
+	return 0;
+}
+
+
+/* per tq stats maintained by the device */
+static const struct vmxnet3_stat_desc
+vmxnet3_tq_dev_stats[] = {
+	/* description,         offset */
+	{ "TSO pkts tx",        offsetof(UPT1_TxStats, TSOPktsTxOK) },
+	{ "TSO bytes tx",       offsetof(UPT1_TxStats, TSOBytesTxOK) },
+	{ "ucast pkts tx",      offsetof(UPT1_TxStats, ucastPktsTxOK) },
+	{ "ucast bytes tx",     offsetof(UPT1_TxStats, ucastBytesTxOK) },
+	{ "mcast pkts tx",      offsetof(UPT1_TxStats, mcastPktsTxOK) },
+	{ "mcast bytes tx",     offsetof(UPT1_TxStats, mcastBytesTxOK) },
+	{ "bcast pkts tx",      offsetof(UPT1_TxStats, bcastPktsTxOK) },
+	{ "bcast bytes tx",     offsetof(UPT1_TxStats, bcastBytesTxOK) },
+	{ "pkts tx err",        offsetof(UPT1_TxStats, pktsTxError) },
+	{ "pkts tx discard",    offsetof(UPT1_TxStats, pktsTxDiscard) },
+};
+
+/* per tq stats maintained by the driver */
+static const struct vmxnet3_stat_desc
+vmxnet3_tq_driver_stats[] = {
+	/* description,         offset */
+	{"drv dropped tx total", offsetof(struct vmxnet3_tq_driver_stats,
+					drop_total) },
+	{ "   too many frags",  offsetof(struct vmxnet3_tq_driver_stats,
+					drop_too_many_frags) },
+	{ "   giant hdr",       offsetof(struct vmxnet3_tq_driver_stats,
+					drop_oversized_hdr) },
+	{ "   hdr err",         offsetof(struct vmxnet3_tq_driver_stats,
+					drop_hdr_inspect_err) },
+	{ "   tso",             offsetof(struct vmxnet3_tq_driver_stats,
+					drop_tso) },
+	{ "ring full",          offsetof(struct vmxnet3_tq_driver_stats,
+					tx_ring_full) },
+	{ "pkts linearized",    offsetof(struct vmxnet3_tq_driver_stats,
+					linearized) },
+	{ "hdr cloned",         offsetof(struct vmxnet3_tq_driver_stats,
+					copy_skb_header) },
+	{ "giant hdr",          offsetof(struct vmxnet3_tq_driver_stats,
+					oversized_hdr) },
+};
+
+/* per rq stats maintained by the device */
+static const struct vmxnet3_stat_desc
+vmxnet3_rq_dev_stats[] = {
+	{ "LRO pkts rx",        offsetof(UPT1_RxStats, LROPktsRxOK) },
+	{ "LRO byte rx",        offsetof(UPT1_RxStats, LROBytesRxOK) },
+	{ "ucast pkts rx",      offsetof(UPT1_RxStats, ucastPktsRxOK) },
+	{ "ucast bytes rx",     offsetof(UPT1_RxStats, ucastBytesRxOK) },
+	{ "mcast pkts rx",      offsetof(UPT1_RxStats, mcastPktsRxOK) },
+	{ "mcast bytes rx",     offsetof(UPT1_RxStats, mcastBytesRxOK) },
+	{ "bcast pkts rx",      offsetof(UPT1_RxStats, bcastPktsRxOK) },
+	{ "bcast bytes rx",     offsetof(UPT1_RxStats, bcastBytesRxOK) },
+	{ "pkts rx out of buf", offsetof(UPT1_RxStats, pktsRxOutOfBuf) },
+	{ "pkts rx err",        offsetof(UPT1_RxStats, pktsRxError) },
+};
+
+/* per rq stats maintained by the driver */
+static const struct vmxnet3_stat_desc
+vmxnet3_rq_driver_stats[] = {
+	/* description,         offset */
+	{ "drv dropped rx total", offsetof(struct vmxnet3_rq_driver_stats,
+					   drop_total) },
+	{ "   err",            offsetof(struct vmxnet3_rq_driver_stats,
+					drop_err) },
+	{ "   fcs",            offsetof(struct vmxnet3_rq_driver_stats,
+					drop_fcs) },
+	{ "rx buf alloc fail", offsetof(struct vmxnet3_rq_driver_stats,
+					rx_buf_alloc_failure) },
+};
+
+/* gloabl stats maintained by the driver */
+static const struct vmxnet3_stat_desc
+vmxnet3_global_stats[] = {
+	/* description,         offset */
+	{ "tx timeout count",   offsetof(struct vmxnet3_adapter,
+					 tx_timeout_count) }
+};
+
+/* Returns pointer to net_device_stats struct in the adapter/netdev */
+struct net_device_stats *
+vmxnet3_get_stats(struct net_device *netdev)
+{
+	struct vmxnet3_adapter *adapter;
+	struct vmxnet3_tq_driver_stats *drvTxStats;
+	struct vmxnet3_rq_driver_stats *drvRxStats;
+	struct UPT1_TxStats *devTxStats;
+	struct UPT1_RxStats *devRxStats;
+	struct net_device_stats *net_stats;
+
+	adapter = compat_netdev_priv(netdev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+	net_stats = &adapter->net_stats;
+#else
+	net_stats = &netdev->stats;
+#endif
+
+	/* Collect the dev stats into the shared area */
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD, VMXNET3_CMD_GET_STATS);
+
+	/* Assuming that we have a single queue device */
+	devTxStats = &adapter->tqd_start->stats;
+	devRxStats = &adapter->rqd_start->stats;
+
+	/* Get access to the driver stats per queue */
+	drvTxStats = &adapter->tx_queue.stats;
+	drvRxStats = &adapter->rx_queue.stats;
+
+	memset(net_stats, 0, sizeof(*net_stats));
+
+	net_stats->rx_packets = devRxStats->ucastPktsRxOK +
+				devRxStats->mcastPktsRxOK +
+				devRxStats->bcastPktsRxOK;
+
+	net_stats->tx_packets = devTxStats->ucastPktsTxOK +
+				devTxStats->mcastPktsTxOK +
+				devTxStats->bcastPktsTxOK;
+
+	net_stats->rx_bytes = devRxStats->ucastBytesRxOK +
+			      devRxStats->mcastBytesRxOK +
+			      devRxStats->bcastBytesRxOK;
+
+	net_stats->tx_bytes = devTxStats->ucastBytesTxOK +
+			      devTxStats->mcastBytesTxOK +
+			      devTxStats->bcastBytesTxOK;
+
+	net_stats->rx_errors = devRxStats->pktsRxError;
+	net_stats->tx_errors = devTxStats->pktsTxError;
+	net_stats->rx_dropped = drvRxStats->drop_total;
+	net_stats->tx_dropped = drvTxStats->drop_total;
+	net_stats->multicast =  devRxStats->mcastPktsRxOK;
+
+	return net_stats;
+}
+
+/* Returns the number of counters we will return in vmxnet3_get_ethtool_stats.
+ * Assume each counter is uint64.
+ */
+static int
+vmxnet3_get_stats_count(struct net_device *netdev)
+{
+	return ARRAY_SIZE(vmxnet3_tq_dev_stats) +
+		ARRAY_SIZE(vmxnet3_tq_driver_stats) +
+		ARRAY_SIZE(vmxnet3_rq_dev_stats) +
+		ARRAY_SIZE(vmxnet3_rq_driver_stats) +
+		ARRAY_SIZE(vmxnet3_global_stats);
+}
+
+
+static int
+vmxnet3_get_regs_len(struct net_device *netdev)
+{
+	return 20 * sizeof(u32);
+}
+
+
+/*
+ * *drvinfo is updated
+ */
+static void
+vmxnet3_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+
+	strlcpy(drvinfo->driver, vmxnet3_driver_name, sizeof(drvinfo->driver));
+	drvinfo->driver[sizeof(drvinfo->driver) - 1] = '\0';
+
+	strlcpy(drvinfo->version, VMXNET3_DRIVER_VERSION_REPORT,
+		sizeof(drvinfo->version));
+	drvinfo->driver[sizeof(drvinfo->version) - 1] = '\0';
+
+	strlcpy(drvinfo->fw_version, "N/A", sizeof(drvinfo->fw_version));
+	drvinfo->fw_version[sizeof(drvinfo->fw_version) - 1] = '\0';
+
+	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
+		ETHTOOL_BUSINFO_LEN);
+	drvinfo->n_stats = vmxnet3_get_stats_count(netdev);
+	drvinfo->testinfo_len = 0;
+	drvinfo->eedump_len   = 0;
+	drvinfo->regdump_len  = vmxnet3_get_regs_len(netdev);
+}
+
+/* Returns the description strings for the counters returned by
+ * vmxnet3_get_ethtool_stats.
+ */
+static void
+vmxnet3_get_strings(struct net_device *netdev, u32 stringset, u8 *buf)
+{
+	if (stringset == ETH_SS_STATS) {
+		int i;
+
+		for (i = 0; i < ARRAY_SIZE(vmxnet3_tq_dev_stats); i++) {
+			memcpy(buf, vmxnet3_tq_dev_stats[i].desc,
+			       ETH_GSTRING_LEN);
+			buf += ETH_GSTRING_LEN;
+		}
+		for (i = 0; i < ARRAY_SIZE(vmxnet3_tq_driver_stats); i++) {
+			memcpy(buf, vmxnet3_tq_driver_stats[i].desc,
+			       ETH_GSTRING_LEN);
+			buf += ETH_GSTRING_LEN;
+		}
+		for (i = 0; i < ARRAY_SIZE(vmxnet3_rq_dev_stats); i++) {
+			memcpy(buf, vmxnet3_rq_dev_stats[i].desc,
+			       ETH_GSTRING_LEN);
+			buf += ETH_GSTRING_LEN;
+		}
+		for (i = 0; i < ARRAY_SIZE(vmxnet3_rq_driver_stats); i++) {
+			memcpy(buf, vmxnet3_rq_driver_stats[i].desc,
+			       ETH_GSTRING_LEN);
+			buf += ETH_GSTRING_LEN;
+		}
+		for (i = 0; i < ARRAY_SIZE(vmxnet3_global_stats); i++) {
+			memcpy(buf, vmxnet3_global_stats[i].desc,
+				ETH_GSTRING_LEN);
+			buf += ETH_GSTRING_LEN;
+		}
+	}
+}
+
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 23)
+static u32
+vmxnet3_get_flags(struct net_device *netdev) {
+	return netdev->features;
+}
+
+static int
+vmxnet3_set_flags(struct net_device *netdev, u32 data) {
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+	u8 lro_requested = (data & ETH_FLAG_LRO) == 0 ? 0 : 1;
+	u8 lro_present = (netdev->features & NETIF_F_LRO) == 0 ? 0 : 1;
+
+	if (lro_requested != lro_present) {
+		/* toggle the LRO feature*/
+		netdev->features ^= NETIF_F_LRO;
+
+		/* update harware LRO capability accordingly */
+		if (lro_requested)
+			adapter->shared->devRead.misc.uptFeatures &= UPT1_F_LRO;
+		else
+			adapter->shared->devRead.misc.uptFeatures &=
+								~UPT1_F_LRO;
+		VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,
+				       VMXNET3_CMD_UPDATE_FEATURE);
+	}
+	return 0;
+}
+
+#endif
+
+
+static void
+vmxnet3_get_ethtool_stats(struct net_device *netdev,
+			  struct ethtool_stats *stats, u64 *buf)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+	u8 *base;
+	int i;
+
+	VMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD, VMXNET3_CMD_GET_STATS);
+
+	/* this does assume each counter is 64-bit wide */
+
+	base = (u8 *)&adapter->tqd_start->stats;
+	for (i = 0; i < ARRAY_SIZE(vmxnet3_tq_dev_stats); i++)
+		*buf++ = *(u64 *)(base + vmxnet3_tq_dev_stats[i].offset);
+
+	base = (u8 *)&adapter->tx_queue.stats;
+	for (i = 0; i < ARRAY_SIZE(vmxnet3_tq_driver_stats); i++)
+		*buf++ = *(u64 *)(base + vmxnet3_tq_driver_stats[i].offset);
+
+	base = (u8 *)&adapter->rqd_start->stats;
+	for (i = 0; i < ARRAY_SIZE(vmxnet3_rq_dev_stats); i++)
+		*buf++ = *(u64 *)(base + vmxnet3_rq_dev_stats[i].offset);
+
+	base = (u8 *)&adapter->rx_queue.stats;
+	for (i = 0; i < ARRAY_SIZE(vmxnet3_rq_driver_stats); i++)
+		*buf++ = *(u64 *)(base + vmxnet3_rq_driver_stats[i].offset);
+
+	base = (u8 *)adapter;
+	for (i = 0; i < ARRAY_SIZE(vmxnet3_global_stats); i++)
+		*buf++ = *(u64 *)(base + vmxnet3_global_stats[i].offset);
+}
+
+
+static void
+vmxnet3_get_regs(struct net_device *netdev, struct ethtool_regs *regs, void *p)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+	u32 *buf = p;
+
+	memset(p, 0, vmxnet3_get_regs_len(netdev));
+
+	regs->version = 1;
+
+	/* Update vmxnet3_get_regs_len if we want to dump more registers */
+
+	/* make each ring use multiple of 16 bytes */
+	buf[0] = adapter->tx_queue.tx_ring.next2fill;
+	buf[1] = adapter->tx_queue.tx_ring.next2comp;
+	buf[2] = adapter->tx_queue.tx_ring.gen;
+	buf[3] = 0;
+
+	buf[4] = adapter->tx_queue.comp_ring.next2proc;
+	buf[5] = adapter->tx_queue.comp_ring.gen;
+	buf[6] = adapter->tx_queue.stopped;
+	buf[7] = 0;
+
+	buf[8] = adapter->rx_queue.rx_ring[0].next2fill;
+	buf[9] = adapter->rx_queue.rx_ring[0].next2comp;
+	buf[10] = adapter->rx_queue.rx_ring[0].gen;
+	buf[11] = 0;
+
+	buf[12] = adapter->rx_queue.rx_ring[1].next2fill;
+	buf[13] = adapter->rx_queue.rx_ring[1].next2comp;
+	buf[14] = adapter->rx_queue.rx_ring[1].gen;
+	buf[15] = 0;
+
+	buf[16] = adapter->rx_queue.comp_ring.next2proc;
+	buf[17] = adapter->rx_queue.comp_ring.gen;
+	buf[18] = 0;
+	buf[19] = 0;
+}
+
+
+static void
+vmxnet3_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+
+	wol->supported = WAKE_UCAST | WAKE_ARP | WAKE_MAGIC;
+	wol->wolopts = adapter->wol;
+}
+
+
+static int
+vmxnet3_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+
+	if (wol->wolopts & (WAKE_PHY | WAKE_MCAST | WAKE_BCAST |
+			    WAKE_MAGICSECURE)) {
+		return -EOPNOTSUPP;
+	}
+
+	adapter->wol = wol->wolopts;
+
+	compat_device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
+
+	return 0;
+}
+
+
+static int
+vmxnet3_get_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+
+	ecmd->supported = SUPPORTED_10000baseT_Full | SUPPORTED_1000baseT_Full |
+			  SUPPORTED_TP;
+	ecmd->advertising = ADVERTISED_TP;
+	ecmd->port = PORT_TP;
+	ecmd->transceiver = XCVR_INTERNAL;
+
+	if (adapter->link_speed) {
+		ecmd->speed = adapter->link_speed;
+		ecmd->duplex = DUPLEX_FULL;
+	} else {
+		ecmd->speed = -1;
+		ecmd->duplex = -1;
+	}
+	return 0;
+}
+
+
+static void
+vmxnet3_get_ringparam(struct net_device *netdev,
+		      struct ethtool_ringparam *param)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+
+	param->rx_max_pending = VMXNET3_RX_RING_MAX_SIZE;
+	param->tx_max_pending = VMXNET3_TX_RING_MAX_SIZE;
+	param->rx_mini_max_pending = 0;
+	param->rx_jumbo_max_pending = 0;
+
+	param->rx_pending = adapter->rx_queue.rx_ring[0].size;
+	param->tx_pending = adapter->tx_queue.tx_ring.size;
+	param->rx_mini_pending = 0;
+	param->rx_jumbo_pending = 0;
+}
+
+
+
+static int
+vmxnet3_set_ringparam(struct net_device *netdev,
+		      struct ethtool_ringparam *param)
+{
+	struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+	u32 new_tx_ring_size, new_rx_ring_size;
+	u32 sz;
+	int err = 0;
+
+	if (param->tx_pending == 0 ||
+	    param->tx_pending >	VMXNET3_TX_RING_MAX_SIZE)
+		return -EINVAL;
+
+	if (param->rx_pending == 0 ||
+	    param->rx_pending >	VMXNET3_RX_RING_MAX_SIZE)
+		return -EINVAL;
+
+
+	/* round it up to a multiple of VMXNET3_RING_SIZE_ALIGN */
+	new_tx_ring_size = (param->tx_pending + VMXNET3_RING_SIZE_MASK) &
+		~VMXNET3_RING_SIZE_MASK;
+	new_tx_ring_size = min_t(u32, new_tx_ring_size,
+				 VMXNET3_TX_RING_MAX_SIZE);
+	BUG_ON(new_tx_ring_size > VMXNET3_TX_RING_MAX_SIZE);
+	BUG_ON(new_tx_ring_size % VMXNET3_RING_SIZE_ALIGN != 0);
+
+	/* ring0 has to be a multiple of
+	 * rx_buf_per_pkt * VMXNET3_RING_SIZE_ALIGN
+	 */
+	sz = adapter->rx_buf_per_pkt * VMXNET3_RING_SIZE_ALIGN;
+	new_rx_ring_size = (param->rx_pending + sz - 1) / sz * sz;
+	new_rx_ring_size = min_t(u32, new_rx_ring_size,
+			VMXNET3_RX_RING_MAX_SIZE / sz * sz);
+	BUG_ON(new_rx_ring_size > VMXNET3_RX_RING_MAX_SIZE);
+	BUG_ON(new_rx_ring_size % sz != 0);
+
+	if (new_tx_ring_size == adapter->tx_queue.tx_ring.size &&
+			new_rx_ring_size == adapter->rx_queue.rx_ring[0].size) {
+		return 0;
+	}
+
+
+	/*
+	 * Reset_work may be in the middle of resetting the device, wait for its
+	 * completion.
+	 */
+	while (test_and_set_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state))
+		compat_msleep(1);
+
+	if (compat_netif_running(netdev)) {
+		vmxnet3_quiesce_dev(adapter);
+		vmxnet3_reset_dev(adapter);
+
+		/* recreate the rx queue and the tx queue based on the
+		 * new sizes */
+		vmxnet3_tq_destroy(&adapter->tx_queue, adapter);
+		vmxnet3_rq_destroy(&adapter->rx_queue, adapter);
+
+		err = vmxnet3_create_queues(adapter, new_tx_ring_size,
+			new_rx_ring_size, VMXNET3_DEF_RX_RING_SIZE);
+		if (err) {
+			/* failed, most likely because of OOM, try the default
+			 * size */
+			printk(KERN_ERR "%s: failed to apply new sizes, try the"
+				" default ones\n", netdev->name);
+			err = vmxnet3_create_queues(adapter,
+						    VMXNET3_DEF_TX_RING_SIZE,
+						    VMXNET3_DEF_RX_RING_SIZE,
+						    VMXNET3_DEF_RX_RING_SIZE);
+			if (err) {
+				printk(KERN_ERR "%s: failed to create queues "
+					"with default sizes. Closing it\n",
+					netdev->name);
+				goto out;
+			}
+		}
+
+		err = vmxnet3_activate_dev(adapter);
+		if (err)
+			printk(KERN_ERR "%s: failed to re-activate, error %d."
+				" Closing it\n", netdev->name, err);
+	}
+
+out:
+	clear_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state);
+	if (err)
+		vmxnet3_force_close(adapter);
+
+	return err;
+}
+
+
+static u32
+vmxnet3_get_tx_csum(struct net_device *netdev)
+{
+        return (netdev->features & NETIF_F_HW_CSUM) != 0;
+}
+
+static int
+vmxnet3_set_tx_csum(struct net_device *netdev, u32 val)
+{
+        struct vmxnet3_adapter *adapter = compat_netdev_priv(netdev);
+        if (val) {
+                netdev->features |= NETIF_F_HW_CSUM;
+        } else {
+                netdev->features &= ~ NETIF_F_HW_CSUM;
+        }
+        vmxnet3_vlan_features(adapter, 0, TRUE);
+        return 0;
+}
+
+
+static struct ethtool_ops vmxnet3_ethtool_ops = {
+	.get_settings      = vmxnet3_get_settings,
+	.get_drvinfo       = vmxnet3_get_drvinfo,
+	.get_regs_len      = vmxnet3_get_regs_len,
+	.get_regs          = vmxnet3_get_regs,
+	.get_wol           = vmxnet3_get_wol,
+	.set_wol           = vmxnet3_set_wol,
+	.get_link          = ethtool_op_get_link,
+	.get_rx_csum       = vmxnet3_get_rx_csum,
+	.set_rx_csum       = vmxnet3_set_rx_csum,
+	.get_tx_csum       = vmxnet3_get_tx_csum,
+	.set_tx_csum       = vmxnet3_set_tx_csum,
+	.get_sg            = ethtool_op_get_sg,
+	.set_sg            = ethtool_op_set_sg,
+	.get_tso           = ethtool_op_get_tso,
+	.set_tso           = ethtool_op_set_tso,
+	.get_strings       = vmxnet3_get_strings,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 23)
+	.get_flags	   = vmxnet3_get_flags,
+	.set_flags	   = vmxnet3_set_flags,
+#endif
+	.get_stats_count   = vmxnet3_get_stats_count,
+	.get_ethtool_stats = vmxnet3_get_ethtool_stats,
+	.get_ringparam     = vmxnet3_get_ringparam,
+	.set_ringparam     = vmxnet3_set_ringparam,
+};
+
+void vmxnet3_set_ethtool_ops(struct net_device *netdev)
+{
+	SET_ETHTOOL_OPS(netdev, &vmxnet3_ethtool_ops);
+}
+
diff -w -N -r -u open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/vmxnet3_int.h open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/vmxnet3_int.h
--- open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/vmxnet3_int.h	1970-01-01 01:00:00.000000000 +0100
+++ open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/vmxnet3_int.h	2009-12-17 22:47:42.000000000 +0100
@@ -0,0 +1,412 @@
+/*********************************************************
+ * Copyright (C) 2007 VMware, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation version 2 and no later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ *
+ *********************************************************/
+
+#ifndef _VMXNET3_INT_H
+#define _VMXNET3_INT_H
+
+#define INCLUDE_ALLOW_MODULE
+#include "includeCheck.h"
+
+#include "compat_slab.h"
+#include "compat_spinlock.h"
+#include "compat_ioport.h"
+#include "compat_pci.h"
+#include "compat_highmem.h"
+#include "compat_init.h"
+#include "compat_timer.h"
+#include "compat_netdevice.h"
+#include "compat_skbuff.h"
+#include "compat_interrupt.h"
+#include "compat_workqueue.h"
+#include "compat_module.h"
+
+#include <asm/dma.h>
+#include <asm/page.h>
+#include <asm/uaccess.h>
+#include <linux/types.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <linux/in.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <asm/checksum.h>
+#include <linux/moduleparam.h>
+
+
+#include <linux/if_vlan.h>
+#include <linux/if_arp.h>
+#include <linux/inetdevice.h>
+
+#ifdef CONFIG_COMPAT
+#ifndef HAVE_UNLOCKED_IOCTL
+#include <linux/ioctl32.h>
+#endif
+#endif
+
+#include "vm_basic_types.h"
+#include "vmxnet3_defs.h"
+#include "vmxnet3_version.h"
+#include <linux/stddef.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0) && !defined(VMXNET3_NO_NAPI)
+#   define VMXNET3_NAPI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24) || defined NETIF_F_GRO
+/*
+ * The new NAPI initially appeared only in 2.6.24 but Redhat backported it
+ * to 2.6.18 in RHEL5.4. We assume that iwe need to use the new style
+ * whenever NETIF_F_GRO is present.
+ */
+#   define VMXNET3_NEW_NAPI
+#endif
+#endif
+
+
+#ifdef VLAN_GROUP_ARRAY_SPLIT_PARTS
+#define compat_vlan_group_get_device(vlan_grp, vid)	vlan_group_get_device(vlan_grp, vid)
+#define compat_vlan_group_set_device(vlan_grp, vid, dev)	vlan_group_set_device(vlan_grp, vid, dev)
+#else
+#define compat_vlan_group_get_device(vlan_grp, vid)	((vlan_grp)->vlan_devices[(vid)])
+#define compat_vlan_group_set_device(vlan_grp, vid, dev)	((vlan_grp)->vlan_devices[(vid)] = (dev))
+#endif
+
+
+#ifdef VMXNET3_NAPI
+#   ifdef VMX86_DEBUG
+#      define VMXNET3_DRIVER_VERSION_REPORT VMXNET3_DRIVER_VERSION_STRING"-NAPI(debug)"
+#   else
+#      define VMXNET3_DRIVER_VERSION_REPORT VMXNET3_DRIVER_VERSION_STRING"-NAPI"
+#   endif
+#else
+#   ifdef VMX86_DEBUG
+#      define VMXNET3_DRIVER_VERSION_REPORT VMXNET3_DRIVER_VERSION_STRING"(debug)"
+#   else
+#      define VMXNET3_DRIVER_VERSION_REPORT VMXNET3_DRIVER_VERSION_STRING
+#   endif
+#endif
+
+
+struct vmxnet3_cmd_ring {
+	Vmxnet3_GenericDesc *base;
+	u32		size;
+	u32		next2fill;
+	u32		next2comp;
+	u8		gen;
+	dma_addr_t           basePA;
+};
+
+static inline void
+vmxnet3_cmd_ring_adv_next2fill(struct vmxnet3_cmd_ring *ring)
+{
+	ring->next2fill++;
+	if (unlikely(ring->next2fill == ring->size)) {
+		ring->next2fill = 0;
+		VMXNET3_FLIP_RING_GEN(ring->gen);
+	}
+}
+
+static inline void
+vmxnet3_cmd_ring_adv_next2comp(struct vmxnet3_cmd_ring *ring)
+{
+	VMXNET3_INC_RING_IDX_ONLY(ring->next2comp, ring->size);
+}
+
+static inline int
+vmxnet3_cmd_ring_desc_avail(struct vmxnet3_cmd_ring *ring)
+{
+	return (ring->next2comp > ring->next2fill ? 0 : ring->size) +
+		ring->next2comp - ring->next2fill - 1;
+}
+
+struct vmxnet3_comp_ring {
+	Vmxnet3_GenericDesc *base;
+	u32               size;
+	u32               next2proc;
+	u8                gen;
+	u8                intr_idx;
+	dma_addr_t        basePA;
+};
+
+static inline void
+vmxnet3_comp_ring_adv_next2proc(struct vmxnet3_comp_ring *ring)
+{
+	ring->next2proc++;
+	if (unlikely(ring->next2proc == ring->size)) {
+		ring->next2proc = 0;
+		VMXNET3_FLIP_RING_GEN(ring->gen);
+	}
+}
+
+struct vmxnet3_tx_data_ring {
+	Vmxnet3_TxDataDesc *base;
+	u32                 size;
+	dma_addr_t          basePA;
+};
+
+enum vmxnet3_buf_map_type {
+	VMXNET3_MAP_INVALID = 0,
+	VMXNET3_MAP_NONE,
+	VMXNET3_MAP_SINGLE,
+	VMXNET3_MAP_PAGE,
+};
+
+struct vmxnet3_tx_buf_info {
+	u32      map_type;
+	u16      len;
+	u16      sop_idx;
+	dma_addr_t  dma_addr;
+	struct sk_buff *skb;
+};
+
+struct vmxnet3_tq_driver_stats {
+	u64 drop_total;     /* # of pkts dropped by the driver, the
+                           * counters below track droppings due to 
+                           * different reasons
+                           */
+	u64 drop_too_many_frags;
+	u64 drop_oversized_hdr;
+	u64 drop_hdr_inspect_err;
+	u64 drop_tso;
+
+	u64 tx_ring_full;
+	u64 linearized;         /* # of pkts linearized */
+	u64 copy_skb_header;    /* # of times we have to copy skb header */
+	u64 oversized_hdr;
+};
+
+struct vmxnet3_tx_ctx {
+	Bool   ipv4;
+	u16 mss;
+	u32 eth_ip_hdr_size; /* only valid for pkts requesting tso or csum
+				 * offloading
+				 */
+	u32 l4_hdr_size;     /* only valid if mss != 0 */
+	u32 copy_size;       /* # of bytes copied into the data ring */
+	Vmxnet3_GenericDesc *sop_txd;
+	Vmxnet3_GenericDesc *eop_txd;
+};
+
+struct vmxnet3_tx_queue {
+	spinlock_t                      tx_lock;
+	struct vmxnet3_cmd_ring         tx_ring;
+	struct vmxnet3_tx_buf_info     *buf_info;
+	struct vmxnet3_tx_data_ring     data_ring;
+	struct vmxnet3_comp_ring        comp_ring;
+	Vmxnet3_TxQueueCtrl            *shared;
+	struct vmxnet3_tq_driver_stats  stats;
+	Bool                            stopped;
+	int                             num_stop;  /* # of times the queue is
+						    * stopped */
+} __attribute__((__aligned__(SMP_CACHE_BYTES)));
+
+enum vmxnet3_rx_buf_type {
+	VMXNET3_RX_BUF_NONE = 0,
+	VMXNET3_RX_BUF_SKB = 1,
+	VMXNET3_RX_BUF_PAGE = 2
+};
+
+struct vmxnet3_rx_buf_info {
+	enum vmxnet3_rx_buf_type buf_type;
+	u16     len;
+	union {
+		struct sk_buff *skb;
+		struct page    *page;
+		unsigned long   shm_idx;
+	};
+	dma_addr_t dma_addr;
+};
+
+struct vmxnet3_rx_ctx {
+	struct sk_buff *skb;
+	u32 sop_idx;
+};
+
+struct vmxnet3_rq_driver_stats {
+	u64 drop_total;
+	u64 drop_err;
+	u64 drop_fcs;
+	u64 rx_buf_alloc_failure;
+};
+
+struct vmxnet3_rx_queue {
+	struct vmxnet3_cmd_ring   rx_ring[2];
+	struct vmxnet3_comp_ring  comp_ring;
+	struct vmxnet3_rx_ctx     rx_ctx;
+	u32 qid;            /* rqID in RCD for buffer from 1st ring */
+	u32 qid2;           /* rqID in RCD for buffer from 2nd ring */
+	u32 uncommitted[2]; /* # of buffers allocated since last RXPROD
+			     * update */
+	struct vmxnet3_rx_buf_info     *buf_info[2];
+	Vmxnet3_RxQueueCtrl            *shared;
+	struct vmxnet3_rq_driver_stats  stats;
+} __attribute__((__aligned__(SMP_CACHE_BYTES)));
+
+#define VMXNET3_LINUX_MAX_MSIX_VECT     1
+
+struct vmxnet3_intr {
+	enum vmxnet3_intr_mask_mode  mask_mode;
+	enum vmxnet3_intr_type       type;          /* MSI-X, MSI, or INTx? */
+	u8  num_intrs;			/* # of intr vectors */
+	u8  event_intr_idx;		/* idx of the intr vector for event */
+	u8  mod_levels[VMXNET3_LINUX_MAX_MSIX_VECT]; /* moderation level */
+#ifdef CONFIG_PCI_MSI
+	struct msix_entry msix_entries[VMXNET3_LINUX_MAX_MSIX_VECT];
+#endif
+};
+
+#define VMXNET3_STATE_BIT_RESETTING   0
+#define VMXNET3_STATE_BIT_QUIESCED    1
+struct vmxnet3_adapter {
+	struct vmxnet3_tx_queue        tx_queue;
+	struct vmxnet3_rx_queue        rx_queue;
+#ifdef VMXNET3_NAPI
+	struct napi_struct             napi;
+#endif
+	struct vlan_group             *vlan_grp;
+
+	struct vmxnet3_intr            intr;
+
+	Vmxnet3_DriverShared		*shared;
+	Vmxnet3_PMConf			*pm_conf;
+	Vmxnet3_TxQueueDesc		*tqd_start;    /* first tx queue desc */
+	Vmxnet3_RxQueueDesc		*rqd_start;    /* first rx queue desc */
+	struct net_device             *netdev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+	struct net_device_stats        net_stats;
+#endif
+	struct pci_dev                *pdev;
+
+	u8				*hw_addr0; /* for BAR 0 */
+	u8				*hw_addr1; /* for BAR 1 */
+
+	/* feature control */
+	Bool				rxcsum;
+	Bool				lro;
+	Bool				jumbo_frame;
+
+	/* rx buffer related */
+	unsigned   skb_buf_size;
+	int        rx_buf_per_pkt;  /* only apply to the 1st ring */
+	dma_addr_t shared_pa;
+	dma_addr_t queue_desc_pa;
+
+	/* Wake-on-LAN */
+	u32     wol;
+
+	/* Link speed */
+	u32     link_speed; /* in mbps */
+
+	u64     tx_timeout_count;
+	compat_work work;
+
+	unsigned long  state;    /* VMXNET3_STATE_BIT_xxx */
+
+	int dev_number;
+	Bool is_shm;
+	struct vmxnet3_shm_pool *shm;
+};
+
+struct vmxnet3_stat_desc {
+	char desc[ETH_GSTRING_LEN];
+	int  offset;
+};
+
+#define VMXNET3_WRITE_BAR0_REG(adapter, reg, val)  \
+	writel(cpu_to_le32(val), (adapter)->hw_addr0 + (reg))
+#define VMXNET3_READ_BAR0_REG(adapter, reg)        \
+	le32_to_cpu(readl((adapter)->hw_addr0 + (reg)))
+
+#define VMXNET3_WRITE_BAR1_REG(adapter, reg, val)  \
+	writel(cpu_to_le32(val), (adapter)->hw_addr1 + (reg))
+#define VMXNET3_READ_BAR1_REG(adapter, reg)        \
+	le32_to_cpu(readl((adapter)->hw_addr1 + (reg)))
+
+#define VMXNET3_WAKE_QUEUE_THRESHOLD(tq)  (5)
+#define VMXNET3_RX_ALLOC_THRESHOLD(rq, ring_idx, adapter) \
+	((rq)->rx_ring[ring_idx].size >> 3)
+
+#define VMXNET3_GET_ADDR_LO(dma)   ((u32)(dma))
+#define VMXNET3_GET_ADDR_HI(dma)   ((u32)(((u64)(dma)) >> 32))
+
+/* must be a multiple of VMXNET3_RING_SIZE_ALIGN */
+#define VMXNET3_DEF_TX_RING_SIZE    512
+#define VMXNET3_DEF_RX_RING_SIZE    256
+
+/* FIXME: what's the right value for this? */
+#define VMXNET3_MAX_ETH_HDR_SIZE    22
+
+#define VMXNET3_MAX_SKB_BUF_SIZE    (3*1024)
+
+static inline void
+set_flag_le16(__le16 *data, u16 flag)
+{
+	*data = cpu_to_le16(le16_to_cpu(*data) | flag);
+}
+
+static inline void
+set_flag_le64(__le64 *data, u64 flag)
+{
+	*data = cpu_to_le64(le64_to_cpu(*data) | flag);
+}
+
+static inline void
+reset_flag_le64(__le64 *data, u64 flag)
+{
+	*data = cpu_to_le64(le64_to_cpu(*data) & ~flag);
+}
+
+int
+vmxnet3_tq_xmit(struct sk_buff *skb, struct vmxnet3_tx_queue *tq, struct
+		vmxnet3_adapter *adapter, struct net_device *netdev);
+int
+vmxnet3_quiesce_dev(struct vmxnet3_adapter *adapter);
+
+int
+vmxnet3_activate_dev(struct vmxnet3_adapter *adapter);
+
+void
+vmxnet3_force_close(struct vmxnet3_adapter *adapter);
+
+void
+vmxnet3_reset_dev(struct vmxnet3_adapter *adapter);
+
+void
+vmxnet3_tq_destroy(struct vmxnet3_tx_queue *tq,
+		   struct vmxnet3_adapter *adapter);
+
+void
+vmxnet3_rq_destroy(struct vmxnet3_rx_queue *rq,
+		   struct vmxnet3_adapter *adapter);
+
+int
+vmxnet3_create_queues(struct vmxnet3_adapter *adapter,
+		      u32 tx_ring_size, u32 rx_ring_size, u32 rx_ring2_size);
+
+void
+vmxnet3_vlan_features(struct vmxnet3_adapter *adapter, u16 vid, Bool allvids);
+
+extern void vmxnet3_set_ethtool_ops(struct net_device *netdev);
+extern struct net_device_stats *vmxnet3_get_stats(struct net_device *netdev);
+
+extern char vmxnet3_driver_name[];
+
+
+#endif
diff -w -N -r -u open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/vmxnet3_shm.c open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/vmxnet3_shm.c
--- open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/vmxnet3_shm.c	1970-01-01 01:00:00.000000000 +0100
+++ open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/vmxnet3_shm.c	2009-12-17 22:26:31.000000000 +0100
@@ -0,0 +1,1531 @@
+/*********************************************************
+ * Copyright (C) 2009 VMware, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation version 2 and no later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ *
+ *********************************************************/
+
+/*
+ * vmxnet3_shm.c --
+ *
+ *    Shared memory infrastructure for VMXNET3 linux driver. Used by the
+ *    VMXNET3 driver to back its rings with memory from a shared memory
+ *    pool that is shared with user space.
+ */
+#include "driver-config.h"
+
+#include "vmxnet3_int.h"
+#include "vmnet_def.h"
+#include "vm_device_version.h"
+#include "vmxnet3_shm.h"
+
+
+static int
+vmxnet3_shm_consume_user_tx_queue(struct vmxnet3_shm_pool *shm);
+
+int
+vmxnet3_shm_tq_xmit(struct sk_buff *skb,
+		struct vmxnet3_tx_queue *tq,
+		struct vmxnet3_adapter *adapter,
+		struct net_device *netdev);
+
+/*
+ *----------------------------------------------------------------------------
+ *
+ * kernel_rx_idx --
+ *
+ * Result:
+ *    Kernel's current shared memory RX ring index
+ *
+ * Side-effects:
+ *    None
+ *
+ *----------------------------------------------------------------------------
+ */
+
+static inline u16
+kernel_rx_idx(const struct vmxnet3_shm_pool *shm)
+{
+	return shm->ctl.ptr->kernel_rxi;
+}
+
+
+/*
+ *----------------------------------------------------------------------------
+ *
+ * inc_kernel_rx_idx --
+ *
+ * Result:
+ *    None
+ *
+ * Side-effects:
+ *    Increment the kernel's shared memory RX ring index
+ *
+ *----------------------------------------------------------------------------
+ */
+
+static inline void
+inc_kernel_rx_idx(const struct vmxnet3_shm_pool *shm)
+{
+	shm->ctl.ptr->kernel_rxi = (shm->ctl.ptr->kernel_rxi + 1) % SHM_RX_RING_SIZE;
+}
+
+
+/*
+ *----------------------------------------------------------------------------
+ *
+ * kernel_rx_idx --
+ *
+ * Result:
+ *    Kernel's current shared memory RX ring index
+ *
+ * Side-effects:
+ *    None
+ *
+ *----------------------------------------------------------------------------
+ */
+
+static inline u16
+kernel_tx_idx(const struct vmxnet3_shm_pool *shm)
+{
+	return shm->ctl.ptr->kernel_txi;
+}
+
+
+/*
+ *----------------------------------------------------------------------------
+ *
+ * inc_kernel_tx_idx --
+ *
+ * Result:
+ *    None
+ *
+ * Side-effects:
+ *    Increment the kernel's shared memory TX ring index
+ *
+ *----------------------------------------------------------------------------
+ */
+
+static inline void
+inc_kernel_tx_idx(const struct vmxnet3_shm_pool *shm)
+{
+	shm->ctl.ptr->kernel_txi = (shm->ctl.ptr->kernel_txi + 1) % SHM_TX_RING_SIZE;
+}
+
+
+/*
+ *----------------------------------------------------------------------------
+ *
+ * user_rx_idx --
+ *
+ * Result:
+ *    Users's current shared memory RX ring index
+ *
+ * Side-effects:
+ *    None
+ *
+ *----------------------------------------------------------------------------
+ */
+
+static inline u16
+user_rx_idx(const struct vmxnet3_shm_pool *shm)
+{
+	return shm->ctl.ptr->user_rxi;
+}
+
+/*
+ *----------------------------------------------------------------------------
+ *
+ * kernel_rx_entry --
+ *
+ * Result:
+ *    Kernel's current shared memory RX ring entry
+ *
+ * Side-effects:
+ *    None
+ *
+ *----------------------------------------------------------------------------
+ */
+
+static inline struct vmxnet3_shm_ringentry *
+kernel_rx_entry(const struct vmxnet3_shm_pool *shm)
+{
+	return &shm->ctl.ptr->rx_ring[kernel_rx_idx(shm)];
+}
+
+/*
+ *----------------------------------------------------------------------------
+ *
+ * kernel_tx_entry --
+ *
+ * Result:
+ *    Kernel's current shared memory TX ring entry
+ *
+ * Side-effects:
+ *    None
+ *
+ *----------------------------------------------------------------------------
+ */
+
+static inline struct vmxnet3_shm_ringentry *
+kernel_tx_entry(const struct vmxnet3_shm_pool *shm)
+{
+	return &shm->ctl.ptr->tx_ring[kernel_tx_idx(shm)];
+}
+
+
+/*
+ *----------------------------------------------------------------------------
+ *
+ * user_rx_entry --
+ *
+ * Used by vmxnet3_shm_chardev_poll
+ *
+ * Result:
+ *    User's current shared memory RX ring entry
+ *
+ * Side-effects:
+ *    None
+ *
+ *----------------------------------------------------------------------------
+ */
+
+static inline struct vmxnet3_shm_ringentry *
+user_rx_entry(const struct vmxnet3_shm_pool *shm)
+{
+	return &shm->ctl.ptr->rx_ring[user_rx_idx(shm)];
+}
+
+
+/* kobject type */
+static void
+vmxnet3_shm_pool_release(struct kobject *kobj);
+
+static const struct kobj_type vmxnet3_shm_pool_type = {
+	.release = vmxnet3_shm_pool_release
+};
+
+/* vm operations */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+static int
+vmxnet3_shm_chardev_fault(struct vm_area_struct *vma,
+		struct vm_fault *vmf);
+
+static struct vm_operations_struct vmxnet3_shm_vm_ops = {
+	.fault = vmxnet3_shm_chardev_fault,
+};
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 1)
+static struct page *
+vmxnet3_shm_chardev_nopage(struct vm_area_struct *vma,
+		unsigned long address,
+		int *type);
+
+static struct vm_operations_struct vmxnet3_shm_vm_ops = {
+	.nopage = vmxnet3_shm_chardev_nopage,
+};
+#else
+static struct page *
+vmxnet3_shm_chardev_nopage(struct vm_area_struct *vma,
+		unsigned long address,
+		int unused);
+
+static struct vm_operations_struct vmxnet3_shm_vm_ops = {
+	.nopage = vmxnet3_shm_chardev_nopage,
+};
+#endif
+
+/* file operations */
+static int vmxnet3_shm_chardev_mmap(struct file *filp,
+		struct vm_area_struct *vma);
+
+static int vmxnet3_shm_chardev_open(struct inode * inode,
+		struct file * filp);
+
+static int vmxnet3_shm_chardev_release(struct inode * inode,
+		struct file * filp);
+
+static unsigned int vmxnet3_shm_chardev_poll(struct file *filp,
+		poll_table *wait);
+
+static long vmxnet3_shm_chardev_ioctl(struct file *filp,
+		unsigned int cmd,
+		unsigned long arg);
+
+#ifndef HAVE_UNLOCKED_IOCTL
+static int vmxnet3_shm_chardev_old_ioctl(struct inode *inode,
+		struct file *filp,
+		unsigned int cmd,
+		unsigned long arg);
+#endif
+
+static struct file_operations shm_fops = {
+	.owner = THIS_MODULE,
+	.mmap = vmxnet3_shm_chardev_mmap,
+	.open = vmxnet3_shm_chardev_open,
+	.release = vmxnet3_shm_chardev_release,
+	.poll = vmxnet3_shm_chardev_poll,
+#ifdef HAVE_UNLOCKED_IOCTL
+	.unlocked_ioctl = vmxnet3_shm_chardev_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = vmxnet3_shm_chardev_ioctl,
+#endif
+#else
+	.ioctl = vmxnet3_shm_chardev_old_ioctl,
+#endif
+};
+
+static LIST_HEAD(vmxnet3_shm_list);
+static spinlock_t vmxnet3_shm_list_lock = SPIN_LOCK_UNLOCKED;
+
+/* vmxnet3_shm_pool kobject */
+
+
+/* Lifecycle */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+#define compat_kobject_init(kobj, ktype) { kobject_init(kobj, (struct kobj_type *) ktype); }
+#else
+#define compat_kobject_init(kobj, _ktype) {  \
+	(kobj)->ktype = (struct kobj_type *) _ktype; \
+	kobject_init(kobj); \
+}
+#endif
+
+
+/*
+ *----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_init_allocator --
+ *
+ * Zero all shared memory data pages and fill the allocator with them.
+ *
+ * Result:
+ *    None
+ *
+ *----------------------------------------------------------------------------
+ */
+
+static void
+vmxnet3_shm_init_allocator(struct vmxnet3_shm_pool *shm)
+{
+	int i;
+
+	shm->allocator.count = 0;
+	for (i = 1; i < shm->data.num_pages; i++) {
+		struct page *page = VMXNET3_SHM_IDX2PAGE(shm, i);
+		void *virt = kmap(page);
+		memset(virt, 0, PAGE_SIZE);
+		kunmap(page);
+
+		shm->allocator.stack[shm->allocator.count++] = i;
+
+		BUG_ON(i == SHM_INVALID_IDX);
+	}
+	BUG_ON(shm->allocator.count > shm->data.num_pages);
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_pool_reset --
+ *
+ *    Clean up after userspace has closed the device
+ *
+ * Results:
+ *    None.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static void
+vmxnet3_shm_pool_reset(struct vmxnet3_shm_pool *shm)
+{
+	int err = 0;
+	printk(KERN_INFO "resetting shm pool\n");
+
+	/*
+	 * Reset_work may be in the middle of resetting the device, wait for its
+	 * completion.
+	 */
+	while (test_and_set_bit(VMXNET3_STATE_BIT_RESETTING, &shm->adapter->state))
+		compat_msleep(1);
+
+	if (compat_netif_running(shm->adapter->netdev))
+		vmxnet3_quiesce_dev(shm->adapter);
+
+	vmxnet3_shm_init_allocator(shm);
+
+	if (compat_netif_running(shm->adapter->netdev))
+		err = vmxnet3_activate_dev(shm->adapter);
+
+	memset(shm->ctl.ptr, 0, PAGE_SIZE);
+
+	clear_bit(VMXNET3_STATE_BIT_RESETTING, &shm->adapter->state);
+
+	if (err)
+		vmxnet3_force_close(shm->adapter);
+}
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_pool_create --
+ *
+ *    Allocate and initialize shared memory pool. Allocates the data and
+ *    control pages, resets them to zero, initializes locks, registers the
+ *    character device, etc. Creates virtual address mappings for the pool,
+ *    but does not set up DMA yet.
+ *
+ * Results:
+ *    The new shared memory pool object, or NULL on failure.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+struct vmxnet3_shm_pool *
+vmxnet3_shm_pool_create(struct vmxnet3_adapter *adapter,
+		char *name, int pool_size)
+{
+	int i;
+	unsigned long flags;
+	struct vmxnet3_shm_pool *shm;
+	struct vmxnet3_shm_ctl *ctl_ptr;
+	struct page *ctl_page;
+	int shm_size = sizeof(*shm) +
+		pool_size * sizeof(uint16) +
+		pool_size * sizeof(struct vmxnet3_shm_mapped_page);
+
+	/* Allocate shm_pool kobject */
+	shm = vmalloc(shm_size);
+	if (shm == NULL)
+		goto fail_shm;
+
+	memset(shm, 0, sizeof(*shm));
+	compat_kobject_init(&shm->kobj, &vmxnet3_shm_pool_type);
+	/* shm->kobj.ktype = &vmxnet3_shm_pool_type; */
+	/* kobject_init(&shm->kobj); */
+	snprintf(shm->name, sizeof(shm->name), "vmxnet_%s_shm", name);
+	kobject_set_name(&shm->kobj, shm->name);
+	shm->adapter = adapter;
+
+	/* Allocate data pages */
+	shm->data.num_pages = pool_size;
+	for (i = 1; i < shm->data.num_pages; i++) {
+		struct page *page = alloc_page(GFP_KERNEL);
+		if (page == NULL)
+			goto fail_data;
+
+		VMXNET3_SHM_SET_IDX2PAGE(shm, i, page);
+
+		BUG_ON(i == SHM_INVALID_IDX);
+	}
+
+	/* Allocate control page */
+	ctl_page = alloc_page(GFP_KERNEL);
+	if (ctl_page == NULL)
+		goto fail_ctl;
+
+	ctl_ptr = (void*)kmap(ctl_page);
+	shm->ctl.pages[0] = ctl_page;
+	shm->ctl.ptr = ctl_ptr;
+
+	/* Reset data and control pages */
+	vmxnet3_shm_init_allocator(shm);
+	memset(shm->ctl.ptr, 0, PAGE_SIZE);
+
+	/* Register char device */
+	shm->misc_dev.minor = MISC_DYNAMIC_MINOR;
+	shm->misc_dev.name = shm->name;
+	shm->misc_dev.fops = &shm_fops;
+	if (misc_register(&shm->misc_dev)) {
+		printk(KERN_ERR "failed to register vmxnet3_shm character device\n");
+		goto fail_cdev;
+	}
+
+	/* Initialize locks */
+	spin_lock_init(&shm->alloc_lock);
+	spin_lock_init(&shm->tx_lock);
+	spin_lock_init(&shm->rx_lock);
+	init_waitqueue_head(&shm->rxq);
+
+	spin_lock_irqsave(&vmxnet3_shm_list_lock, flags);
+	list_add(&shm->list, &vmxnet3_shm_list);
+	spin_unlock_irqrestore(&vmxnet3_shm_list_lock, flags);
+
+	printk(KERN_INFO "created vmxnet shared memory pool %s\n", shm->name);
+
+	return shm;
+
+fail_cdev:
+	kunmap(ctl_page);
+	__free_page(ctl_page);
+
+fail_data:
+fail_ctl:
+	for (i = 0; i < shm->data.num_pages; i++) {
+		if (VMXNET3_SHM_IDX2PAGE(shm, i) != NULL)
+			__free_page(VMXNET3_SHM_IDX2PAGE(shm, i));
+	}
+
+	kfree(shm);
+
+fail_shm:
+	return NULL;
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_pool_release --
+ *
+ *    Release a shared memory pool.
+ *
+ * Results:
+ *    None.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static void
+vmxnet3_shm_pool_release(struct kobject *kobj)
+{
+	int i;
+	unsigned long flags;
+	struct vmxnet3_shm_pool *shm = container_of(kobj, struct vmxnet3_shm_pool, kobj);
+
+	spin_lock_irqsave(&vmxnet3_shm_list_lock, flags);
+	list_del(&shm->list);
+	spin_unlock_irqrestore(&vmxnet3_shm_list_lock, flags);
+
+	misc_deregister(&shm->misc_dev);
+
+	/* Free control pages */
+	for (i = 0; i < SHM_CTL_SIZE; i++) {
+		kunmap(shm->ctl.pages[i]);
+		__free_page(shm->ctl.pages[i]);
+	}
+
+	/* Free data pages */
+	for (i = 1; i < shm->data.num_pages; i++)
+		__free_page(VMXNET3_SHM_IDX2PAGE(shm, i));
+
+	printk(KERN_INFO "destroyed vmxnet shared memory pool %s\n", shm->name);
+
+	vfree(shm);
+}
+
+
+/* Shared memory pool management */
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_alloc_page --
+ *
+ *    Allocate a page from the shared memory area.
+ *
+ * Results:
+ *    Index to page or SHM_INVALID_IDX on failure.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+uint16
+vmxnet3_shm_alloc_page(struct vmxnet3_shm_pool *shm)
+{
+	uint16 idx;
+	unsigned long flags;
+
+	spin_lock_irqsave(&shm->alloc_lock, flags);
+	if (shm->allocator.count == 0) {
+		idx = SHM_INVALID_IDX;
+	} else {
+		idx = shm->allocator.stack[--shm->allocator.count];
+		BUG_ON(idx == SHM_INVALID_IDX);
+	}
+	spin_unlock_irqrestore(&shm->alloc_lock, flags);
+
+	return idx;
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_free_page --
+ *
+ *    Free a page back to the shared memory area
+ *
+ * Results:
+ *    None.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+void
+vmxnet3_shm_free_page(struct vmxnet3_shm_pool *shm,
+		uint16 idx)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&shm->alloc_lock, flags);
+	BUG_ON(shm->allocator.count >= shm->data.num_pages);
+	shm->allocator.stack[shm->allocator.count++] = idx;
+	spin_unlock_irqrestore(&shm->alloc_lock, flags);
+}
+
+
+/* Char device */
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_addr2idx --
+ *
+ *    Convert user space address into index into the shared memory pool.
+ *
+ * Results:
+ *    None.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static inline unsigned long
+vmxnet3_shm_addr2idx(struct vm_area_struct *vma,
+		unsigned long address)
+{
+	return vma->vm_pgoff + ((address - vma->vm_start) >> PAGE_SHIFT);
+}
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_chardev_fault --
+ *
+ *    mmap fault handler. Called if the user space requests a page for
+ *    which there is no shared memory mapping yet. We need to lookup
+ *    the page we want to back the shared memory mapping with.
+ *
+ * Results:
+ *    The page backing the user space address.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static int
+vmxnet3_shm_chardev_fault(struct vm_area_struct *vma,
+		struct vm_fault *vmf)
+{
+	struct vmxnet3_shm_pool *shm = vma->vm_private_data;
+	unsigned long address = (unsigned long)vmf->virtual_address;
+	unsigned long idx = vmxnet3_shm_addr2idx(vma, address);
+	struct page *pageptr;
+
+	if (idx >= SHM_DATA_START && idx < SHM_DATA_START + shm->data.num_pages)
+		pageptr = VMXNET3_SHM_IDX2PAGE(shm, idx - SHM_DATA_START);
+	else if (idx >= SHM_CTL_START && idx < SHM_CTL_START + SHM_CTL_SIZE)
+		pageptr = shm->ctl.pages[idx - SHM_CTL_START];
+	else
+		pageptr = NULL;
+
+	if (pageptr)
+		get_page(pageptr);
+
+	vmf->page = pageptr;
+
+	return pageptr ? VM_FAULT_MINOR : VM_FAULT_ERROR;
+}
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 1)
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_chardev_nopage --
+ *
+ *    mmap nopage handler. Called if the user space requests a page for
+ *    which there is no shared memory mapping yet. We need to lookup
+ *    the page we want to back the shared memory mapping with.
+ *
+ * Results:
+ *    The page backing the user space address.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static struct page *
+vmxnet3_shm_chardev_nopage(struct vm_area_struct *vma,
+		unsigned long address,
+		int *type)
+{
+	struct vmxnet3_shm_pool *shm = vma->vm_private_data;
+	unsigned long idx = vmxnet3_shm_addr2idx(vma, address);
+	struct page *pageptr;
+
+	if (idx >= SHM_DATA_START && idx < SHM_DATA_START + shm->data.num_pages)
+		pageptr = VMXNET3_SHM_IDX2PAGE(shm, idx - SHM_DATA_START);
+	else if (idx >= SHM_CTL_START && idx < SHM_CTL_START + SHM_CTL_SIZE)
+		pageptr = shm->ctl.pages[idx - SHM_CTL_START];
+	else
+		pageptr = NULL;
+
+	if (pageptr)
+		get_page(pageptr);
+
+	if (type)
+		*type = pageptr ? VM_FAULT_MINOR : VM_FAULT_SIGBUS;
+
+	return pageptr;
+}
+
+#else
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_chardev_nopage --
+ *
+ *    mmap nopage handler. Called if the user space requests a page for
+ *    which there is no shared memory mapping yet. We need to lookup
+ *    the page we want to back the shared memory mapping with.
+ *
+ * Results:
+ *    The page backing the user space address.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static struct page *
+vmxnet3_shm_chardev_nopage(struct vm_area_struct *vma,
+		unsigned long address,
+		int unused)
+{
+	struct vmxnet3_shm_pool *shm = vma->vm_private_data;
+	unsigned long idx = vmxnet3_shm_addr2idx(vma, address);
+	struct page *pageptr;
+
+	if (idx >= SHM_DATA_START && idx < SHM_DATA_START + shm->data.num_pages)
+		pageptr = VMXNET3_SHM_IDX2PAGE(shm, idx - SHM_DATA_START);
+	else if (idx >= SHM_CTL_START && idx < SHM_CTL_START + SHM_CTL_SIZE)
+		pageptr = shm->ctl.pages[idx - SHM_CTL_START];
+	else
+		pageptr = NULL;
+
+	if (pageptr)
+		get_page(pageptr);
+
+	return pageptr;
+}
+#endif
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_chardev_mmap --
+ *
+ *    Setup mmap.
+ *
+ * Results:
+ *    Always 0.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+static int
+vmxnet3_shm_chardev_mmap(struct file *filp,
+		struct vm_area_struct *vma)
+{
+	vma->vm_private_data = filp->private_data;
+	vma->vm_ops = &vmxnet3_shm_vm_ops;
+	vma->vm_flags |= VM_RESERVED;
+	return 0;
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_chardev_poll --
+ *
+ *    Poll called from user space. We consume the TX queue and then go to
+ *    sleep until we get woken up by an interrupt.
+ *
+ * Results:
+ *    Poll mask.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static unsigned int
+vmxnet3_shm_chardev_poll(struct file *filp,
+		poll_table *wait)
+{
+	struct vmxnet3_shm_pool *shm = filp->private_data;
+	unsigned int mask = 0;
+	unsigned long flags;
+	struct vmxnet3_shm_ringentry *re;
+
+	/* consume TX queue */
+	if (vmxnet3_shm_consume_user_tx_queue(shm) == -1) {
+		/*
+		 * The device has been closed, let the user space
+		 * know there is activity, so that it gets a chance
+		 * to read the channelBad flag.
+		 */
+		mask |= POLLIN;
+		return mask;
+	}
+
+	/* Wait on the rxq for an interrupt to wake us */
+	poll_wait(filp, &shm->rxq, wait);
+
+	/* Check if the user's current RX entry is full */
+	spin_lock_irqsave(&shm->rx_lock, flags);
+	re = user_rx_entry(shm);
+	if (re->own)
+		/* XXX: We need a comment that explains what this does. */
+		mask |= POLLIN | POLLRDNORM;
+
+	spin_unlock_irqrestore(&shm->rx_lock, flags);
+
+	return mask;
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_chardev_ioctl --
+ *
+ *    Handle ioctls from user space.
+ *
+ * Results:
+ *    Return code depends on ioctl.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static long
+vmxnet3_shm_chardev_ioctl(struct file *filp,
+		unsigned int cmd,
+		unsigned long arg)
+{
+	struct vmxnet3_shm_pool *shm = filp->private_data;
+	u16 idx;
+	u16 idx1;
+	int i;
+
+	switch(cmd) {
+
+		case SHM_IOCTL_TX:
+			vmxnet3_shm_consume_user_tx_queue(shm);
+			return 0;
+
+		case SHM_IOCTL_ALLOC_ONE:
+			idx = vmxnet3_shm_alloc_page(shm);
+			return idx;
+
+		case SHM_IOCTL_ALLOC_MANY:
+			for (i = 0; i < arg; i++) {
+				idx = vmxnet3_shm_alloc_page(shm);
+				if (idx != SHM_INVALID_IDX) {
+					if (vmxnet3_shm_user_rx(shm, idx, 0, 1, 1)) {
+						vmxnet3_shm_free_page(shm, idx);
+						return SHM_INVALID_IDX;
+					}
+				} else {
+					return SHM_INVALID_IDX;
+				}
+			}
+			return 0;
+
+		case SHM_IOCTL_ALLOC_ONE_AND_MANY:
+			idx1 = vmxnet3_shm_alloc_page(shm);
+			if (idx1 == SHM_INVALID_IDX)
+				return SHM_INVALID_IDX;
+
+			for (i = 0; i < arg - 1; i++) {
+				idx = vmxnet3_shm_alloc_page(shm);
+				if (idx != SHM_INVALID_IDX) {
+					if (vmxnet3_shm_user_rx(shm, idx, 0, 1, 1)) {
+						vmxnet3_shm_free_page(shm, idx);
+						vmxnet3_shm_free_page(shm, idx1);
+						return SHM_INVALID_IDX;
+					}
+				} else {
+					vmxnet3_shm_free_page(shm, idx1);
+					return SHM_INVALID_IDX;
+				}
+			}
+			return idx1;
+
+		case SHM_IOCTL_FREE_ONE:
+			if (arg != SHM_INVALID_IDX && arg < shm->data.num_pages)
+				vmxnet3_shm_free_page(shm, arg);
+
+			return 0;
+	}
+
+	return -ENOTTY;
+}
+
+#ifndef HAVE_UNLOCKED_IOCTL
+static int vmxnet3_shm_chardev_old_ioctl(struct inode *inode,
+		struct file *filp,
+		unsigned int cmd,
+		unsigned long arg)
+{
+	return vmxnet3_shm_chardev_ioctl(filp, cmd, arg);
+}
+#endif
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_chardev_find_by_minor --
+ *
+ *    Find the right shared memory pool based on the minor number of the
+ *    char device.
+ *
+ * Results:
+ *    Pointer to the shared memory pool, or NULL on error.
+ *
+ * Side effects:
+ *    Takes a reference on the kobj of the shm object.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static struct vmxnet3_shm_pool *
+vmxnet3_shm_chardev_find_by_minor(unsigned int minor)
+{
+	struct vmxnet3_shm_pool *shm, *tmp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&vmxnet3_shm_list_lock, flags);
+
+	list_for_each_entry_safe(shm, tmp, &vmxnet3_shm_list, list) {
+		if (shm->misc_dev.minor == minor && kobject_get(&shm->kobj)) {
+			spin_unlock_irqrestore(&vmxnet3_shm_list_lock, flags);
+			return shm;
+		}
+	}
+
+	spin_unlock_irqrestore(&vmxnet3_shm_list_lock, flags);
+
+	return NULL;
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_chardev_open --
+ *
+ *    Find the right shared memory pool based on the minor number of the
+ *    char device.
+ *
+ * Results:
+ *    0 on success or -ENODEV if no device exists with the given minor number
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static int
+vmxnet3_shm_chardev_open(struct inode * inode,
+		struct file * filp)
+{
+	/* Stash pointer to shm in file so file ops can use it */
+	filp->private_data = vmxnet3_shm_chardev_find_by_minor(iminor(inode));
+	if (filp->private_data == NULL)
+		return -ENODEV;
+
+
+	/* XXX: What does this do?? */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+	/*   filp->f_mapping->backing_dev_info = &directly_mappable_cdev_bdi; */
+#endif
+
+	return 0;
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_chardev_release --
+ *
+ *    Closing the char device. Release the ref count on the shared memory
+ *    pool, perform cleanup.
+ *
+ * Results:
+ *    Always 0.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static int
+vmxnet3_shm_chardev_release(struct inode * inode,
+		struct file * filp)
+{
+	struct vmxnet3_shm_pool *shm = filp->private_data;
+
+	if (shm->adapter) {
+		vmxnet3_shm_pool_reset(shm);
+	} else {
+		vmxnet3_shm_init_allocator(shm);
+		memset(shm->ctl.ptr, 0, PAGE_SIZE);
+	}
+
+	kobject_put(&shm->kobj);
+
+	return 0;
+}
+
+
+/* TX and RX */
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_free_skbpages --
+ *
+ *    Free the shared memory pages (secretly) backing this skb.
+ *
+ * Results:
+ *    None.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+void
+vmxnet3_free_skbpages(struct vmxnet3_adapter *adapter,
+		struct sk_buff *skb)
+{
+	int i;
+
+	vmxnet3_shm_free_page(adapter->shm, VMXNET3_SHM_SKB_GETIDX(skb));
+	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+		struct skb_frag_struct *frag = &skb_shinfo(skb)->frags[i];
+
+		vmxnet3_shm_free_page(adapter->shm, (unsigned long)frag->page);
+	}
+
+	skb_shinfo(skb)->nr_frags = 0;
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_start_tx --
+ *
+ *    The shared memory vmxnet version of the hard_start_xmit routine.
+ *    Just frees the given packet as we do not intend to transmit any
+ *    packet given to us by the TCP/IP stack.
+ *
+ * Results:
+ *    Always 0 for success.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+int
+vmxnet3_shm_start_tx(struct sk_buff *skb,
+		struct net_device *dev)
+{
+	compat_dev_kfree_skb_irq(skb, FREE_WRITE);
+	return COMPAT_NETDEV_TX_OK;
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_tx_pkt --
+ *
+ *    Send a packet (collection of ring entries) using h/w tx routine.
+ *
+ *    Protected by shm.tx_lock
+ *
+ * Results:
+ *    0 on success. Negative value to indicate error
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static int
+vmxnet3_shm_tx_pkt(struct vmxnet3_adapter *adapter,
+		struct vmxnet3_shm_ringentry *res,
+		int frags)
+{
+	struct sk_buff* skb;
+	int i;
+
+	skb = dev_alloc_skb(100);
+	if (skb == NULL) {
+		for (i = 0; i < frags; i++)
+			vmxnet3_shm_free_page(adapter->shm, res[i].idx);
+
+		BUG_ON(TRUE);
+		return -ENOMEM;
+	}
+
+	VMXNET3_SHM_SKB_SETIDX(skb, res[0].idx);
+	VMXNET3_SHM_SKB_SETLEN(skb, res[0].len);
+
+	for (i = 1; i < frags; i++) {
+		struct skb_frag_struct *frag = skb_shinfo(skb)->frags +
+			skb_shinfo(skb)->nr_frags;
+
+		BUG_ON(skb_shinfo(skb)->nr_frags >= MAX_SKB_FRAGS);
+
+		frag->page = (struct page*)(unsigned long)res[i].idx;
+		frag->page_offset = 0;
+		frag->size = res[i].len;
+		skb_shinfo(skb)->nr_frags ++;
+	}
+
+	{
+		struct vmxnet3_tx_queue *tq = &adapter->tx_queue;
+		int ret;
+		skb->protocol = htons(ETH_P_IPV6);
+		adapter->shm->ctl.ptr->stats.kernel_tx += frags; /* XXX: move to better place */
+		ret = vmxnet3_shm_tq_xmit(skb, tq, adapter, adapter->netdev);
+		if (ret == COMPAT_NETDEV_TX_BUSY)
+			vmxnet3_dev_kfree_skb(adapter, skb);
+
+		return ret;
+	}
+
+	return 0;
+}
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_tq_xmit --
+ *
+ *    Wrap vmxnet3_tq_xmit holding the netdev tx lock to better emulate the
+ *    Linux stack. Also check for a stopped tx queue to avoid racing with
+ *    vmxnet3_close.
+ *
+ * Results:
+ *    Same as vmxnet3_tq_xmit.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+int
+vmxnet3_shm_tq_xmit(struct sk_buff *skb,
+		struct vmxnet3_tx_queue *tq,
+		struct vmxnet3_adapter *adapter,
+		struct net_device *netdev)
+{
+	int ret = COMPAT_NETDEV_TX_BUSY;
+	compat_netif_tx_lock(netdev);
+	if (!netif_queue_stopped(netdev))
+		ret = vmxnet3_tq_xmit(skb, tq, adapter, netdev);
+
+	compat_netif_tx_unlock(netdev);
+	return ret;
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_tx_re --
+ *
+ *    Add one entry to the partial TX array. If re->eop is set, i.e. if
+ *    the packet is complete, TX the partial packet.
+ *
+ * Results:
+ *    1 if eop
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static int
+vmxnet3_shm_tx_re(struct vmxnet3_shm_pool *shm,
+		struct vmxnet3_shm_ringentry re)
+{
+	int i;
+
+	BUG_ON(shm->partial_tx.frags > VMXNET3_SHM_MAX_FRAGS);
+	if (shm->partial_tx.frags == VMXNET3_SHM_MAX_FRAGS) {
+		if (re.eop) {
+			printk("dropped oversize shm packet\n");
+			for (i = 0; i < shm->partial_tx.frags; i++)
+				vmxnet3_shm_free_page(shm,
+						shm->partial_tx.res[i].idx);
+
+			shm->partial_tx.frags = 0;
+		}
+		vmxnet3_shm_free_page(shm, re.idx);
+		return re.eop;
+	}
+
+	shm->partial_tx.res[shm->partial_tx.frags++] = re;
+
+	if (re.eop) {
+		int status = vmxnet3_shm_tx_pkt(shm->adapter,
+				shm->partial_tx.res,
+				shm->partial_tx.frags);
+		if (status < 0)
+			printk(KERN_DEBUG "vmxnet3_shm_tx_pkt failed %d\n", status);
+
+		shm->partial_tx.frags = 0;
+		return 1;
+	}
+
+	return 0;
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_consume_user_tx_queue --
+ *
+ *    Consume all packets in the user TX queue and send full
+ *    packets to the device
+ *
+ * Results:
+ *    0 on success.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static int
+vmxnet3_shm_consume_user_tx_queue(struct vmxnet3_shm_pool *shm)
+{
+	unsigned long flags;
+	struct vmxnet3_shm_ringentry *re;
+
+	spin_lock_irqsave(&shm->tx_lock, flags);
+
+	/* Check if the device has been closed */
+	if (shm->adapter == NULL) {
+		spin_unlock_irqrestore(&shm->tx_lock, flags);
+		return -1;
+	}
+
+	/*
+	 * Loop through each full entry in the user TX ring. Discard trash frags and
+	 * add the others to the partial TX array. If an entry has eop set, TX the
+	 * partial packet.
+	 */
+	while ((re = kernel_tx_entry(shm))->own) {
+		if (re->trash) {
+			vmxnet3_shm_free_page(shm, re->idx);
+			shm->ctl.ptr->stats.kernel_tx++;
+		} else {
+			vmxnet3_shm_tx_re(shm, *re);
+		}
+		inc_kernel_tx_idx(shm);
+		*re = RE_ZERO;
+	}
+
+	spin_unlock_irqrestore(&shm->tx_lock, flags);
+
+	return 0;
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_user_desc_available --
+ *
+ *    Checks if we have num_entries ring entries available on the rx ring.
+ *
+ * Results:
+ *    0 for yes
+ *    -ENOMEM for not enough entries available
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+static int
+vmxnet3_shm_user_desc_available(struct vmxnet3_shm_pool *shm,
+		u16 num_entries)
+{
+	struct vmxnet3_shm_ringentry *re;
+	u16 reIdx = kernel_rx_idx(shm);
+
+	while (num_entries > 0) {
+		re = &shm->ctl.ptr->rx_ring[reIdx];
+		if (re->own)
+			return -ENOMEM;
+
+		reIdx = (reIdx + 1) % SHM_RX_RING_SIZE;
+		num_entries--;
+	}
+
+	return 0;
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_rx_skb --
+ *
+ *    Receives an skb into the rx ring. If we can't receive all fragments,
+ *    the entire skb is dropped.
+ *
+ * Results:
+ *    0 for success
+ *    -ENOMEM for not enough entries available
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+int
+vmxnet3_shm_rx_skb(struct vmxnet3_adapter *adapter,
+		struct sk_buff *skb)
+{
+	int ret;
+	int i;
+	int num_entries = 1 + skb_shinfo(skb)->nr_frags;
+	int eop = (num_entries == 1);
+
+	if (vmxnet3_shm_user_desc_available(adapter->shm, num_entries) == -ENOMEM) {
+		vmxnet3_dev_kfree_skb_irq(adapter, skb);
+		return -ENOMEM;
+	}
+
+	ret = vmxnet3_shm_user_rx(adapter->shm,
+			VMXNET3_SHM_SKB_GETIDX(skb),
+			VMXNET3_SHM_SKB_GETLEN(skb),
+			0 /* trash */,
+			eop);
+	if (ret != 0) {
+		BUG_ON(TRUE);
+		printk(KERN_ERR "vmxnet3_shm_user_rx failed on frag 0\n");
+	}
+
+	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+		struct skb_frag_struct *frag = &skb_shinfo(skb)->frags[i];
+		unsigned long shm_idx = (unsigned long)frag->page;
+
+		eop = (i == skb_shinfo(skb)->nr_frags - 1);
+
+		ret = vmxnet3_shm_user_rx(adapter->shm,
+				shm_idx,
+				frag->size,
+				0 /* trash */,
+				eop);
+		if (ret != 0) {
+			BUG_ON(TRUE);
+			printk(KERN_ERR "vmxnet3_shm_user_rx failed on frag 1+\n");
+		}
+	}
+
+
+	/*
+	 * Do NOT use the vmxnet3 version of kfree_skb, as we handed
+	 * ownership of shm pages to the user space, thus we must not
+	 * free them again.
+	 */
+	skb_shinfo(skb)->nr_frags = 0;
+	compat_dev_kfree_skb_irq(skb, FREE_WRITE);
+
+	return 0;
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_user_rx --
+ *
+ *    Put one packet fragment into the shared memory RX ring
+ *
+ * Results:
+ *    0 on success.
+ *    Negative value on error.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+int
+vmxnet3_shm_user_rx(struct vmxnet3_shm_pool *shm,
+		uint16 idx,
+		uint16 len,
+		int trash,
+		int eop)
+{
+	struct vmxnet3_shm_ringentry *re = kernel_rx_entry(shm);
+	shm->ctl.ptr->stats.kernel_rx++;
+	if (re->own)
+		return -ENOMEM;
+
+	inc_kernel_rx_idx(shm);
+	re->idx = idx;
+	re->len = len;
+	re->trash = trash;
+	re->eop = eop;
+	re->own = TRUE;
+	return 0;
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_open --
+ *
+ *    Called when the vmxnet3 device is opened. Allocates the per-device
+ *    shared memory pool.
+ *
+ * Results:
+ *    0 on success.
+ *    Negative value on error.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+int
+vmxnet3_shm_open(struct vmxnet3_adapter *adapter,
+		char *name, int pool_size)
+{
+	if (pool_size > SHM_MAX_DATA_SIZE) {
+		printk(KERN_ERR "vmxnet3_shm: requested pool size %d is larger than the maximum %d\n",
+		       pool_size, SHM_MAX_DATA_SIZE);
+		return -EINVAL;
+	}
+
+	adapter->shm = vmxnet3_shm_pool_create(adapter, name, pool_size);
+	if (adapter->shm == NULL) {
+		printk(KERN_ERR "failed to create shared memory pool\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_shm_close --
+ *
+ *    Called when the vmxnet3 device is closed. Does not free the per-device
+ *    shared memory pool. The character device might still be open. Thus
+ *    freeing the shared memory pool is tied to the ref count on
+ *    shm->kobj dropping to zero instead.
+ *
+ * Results:
+ *    0 on success.
+ *    Negative value on error.
+ *
+ * Side effects:
+ *    None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+int
+vmxnet3_shm_close(struct vmxnet3_adapter *adapter)
+{
+	unsigned long flags;
+
+	/* Can't unset the lp pointer if a TX is in progress */
+	spin_lock_irqsave(&adapter->shm->tx_lock, flags);
+	adapter->shm->adapter = NULL;
+	spin_unlock_irqrestore(&adapter->shm->tx_lock, flags);
+
+	/* Mark the channel as 'in bad state'  */
+	adapter->shm->ctl.ptr->channelBad = 1;
+
+	kobject_put(&adapter->shm->kobj);
+
+	wake_up(&adapter->shm->rxq);
+
+	return 0;
+}
diff -w -N -r -u open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/vmxnet3_shm.h open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/vmxnet3_shm.h
--- open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/vmxnet3_shm.h	1970-01-01 01:00:00.000000000 +0100
+++ open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/vmxnet3_shm.h	2009-12-17 22:26:31.000000000 +0100
@@ -0,0 +1,316 @@
+/*********************************************************
+ * Copyright (C) 2009 VMware, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation version 2 and no later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ *
+ *********************************************************/
+
+/*
+ * vmxnet3_shm.h --
+ *
+ *      Definitions for shared memory infrastructure for VMXNET3 linux driver.
+ */
+
+#ifndef _VMXNET3_SHM_H_
+#define _VMXNET3_SHM_H_
+
+#include "vmxnet3_shm_shared.h"
+#include <linux/miscdevice.h>
+
+/*
+ * Bumping up the max tx descriptor per packet.
+ * We need one more than VMXNET3_SHM_MAX_FRAGS because of partial header copy.
+ */
+#define VMXNET3_MAX_TXD_PER_PKT_SHM (VMXNET3_SHM_MAX_FRAGS + 1)
+
+struct vmxnet3_shm_mapped_page
+{
+	struct page *page;
+	void *virt;
+};
+
+struct vmxnet3_shm_pool
+{
+	struct list_head list;
+	char name[IFNAMSIZ + 16];
+	struct kobject kobj;
+
+	struct
+	{
+		/* pages backing the map in virtual address order */
+		struct vmxnet3_shm_mapped_page *pages;
+		unsigned int num_pages;
+	} data;
+
+	struct
+	{
+		/* pages backing the map in virtual address order */
+		struct page *pages[SHM_CTL_SIZE];
+		struct vmxnet3_shm_ctl *ptr;
+	} ctl;
+
+	struct
+	{
+		/*
+		 * This is a stack of free pages. count is the number of free pages, so
+		 * count - 1 is the topmost free page.
+		 */
+		u16 count;
+		u16 *stack;
+	} allocator;
+
+	struct
+	{
+		struct vmxnet3_shm_ringentry res[VMXNET3_SHM_MAX_FRAGS];
+		int frags;
+	} partial_tx;
+
+	struct miscdevice misc_dev;
+
+	wait_queue_head_t rxq;
+	spinlock_t alloc_lock, tx_lock, rx_lock;
+	struct vmxnet3_adapter *adapter;
+};
+
+/* Convert ring index to the struct page* or virt address. */
+#define VMXNET3_SHM_IDX2PAGE(shm, idx) (shm->data.pages[(idx)].page)
+#define VMXNET3_SHM_SET_IDX2PAGE(shm, idx, x) (shm->data.pages[(idx)].page = (x))
+
+#define VMXNET3_SHM_SKB_GETIDX(skb) (compat_skb_transport_offset(skb))
+#define VMXNET3_SHM_SKB_SETIDX(skb, idx) (compat_skb_set_transport_header(skb, idx))
+#define VMXNET3_SHM_SKB_SETLEN(skb, len) (compat_skb_set_network_header(skb, len))
+#define VMXNET3_SHM_SKB_GETLEN(skb) (compat_skb_network_offset(skb))
+
+int
+vmxnet3_shm_close(struct vmxnet3_adapter *adapter);
+int
+vmxnet3_shm_open(struct vmxnet3_adapter *adapter, char *name, int pool_size);
+int
+vmxnet3_shm_user_rx(struct vmxnet3_shm_pool *shm,
+		u16 idx, u16 len,
+		int trash, int eop);
+void
+vmxnet3_free_skbpages(struct vmxnet3_adapter *adapter, struct sk_buff *skb);
+
+u16
+vmxnet3_shm_alloc_page(struct vmxnet3_shm_pool *shm);
+void
+vmxnet3_shm_free_page(struct vmxnet3_shm_pool *shm, u16 idx);
+
+int
+vmxnet3_shm_start_tx(struct sk_buff *skb, struct net_device *dev);
+int
+vmxnet3_shm_rx_skb(struct vmxnet3_adapter *adapter, struct sk_buff *skb);
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_dev_kfree_skb_* --
+ *
+ *      Covers for dev_kfree_skb*. Deal with the shared memory version of skbs.
+ *
+ * Results:
+ *      None.
+ *
+ * Side effects:
+ *      None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+static inline void
+vmxnet3_dev_kfree_skb(struct vmxnet3_adapter *adapter, struct sk_buff *skb)
+{
+	if (adapter->is_shm)
+		vmxnet3_free_skbpages(adapter, skb);
+
+	compat_dev_kfree_skb(skb, FREE_WRITE);
+}
+
+static inline void
+vmxnet3_dev_kfree_skb_any(struct vmxnet3_adapter *adapter, struct sk_buff *skb)
+{
+	if (adapter->is_shm)
+		vmxnet3_free_skbpages(adapter, skb);
+
+	compat_dev_kfree_skb_any(skb, FREE_WRITE);
+}
+
+static inline void
+vmxnet3_dev_kfree_skb_irq(struct vmxnet3_adapter *adapter, struct sk_buff *skb)
+{
+	if (adapter->is_shm)
+		vmxnet3_free_skbpages(adapter, skb);
+
+	compat_dev_kfree_skb_irq(skb, FREE_WRITE);
+}
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_skb_* --
+ *
+ *      Covers for (compat_)skb_*. Deal with the shared memory version of skbs.
+ *
+ * Results:
+ *      Depends.
+ *
+ * Side effects:
+ *      None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+static inline unsigned int
+vmxnet3_skb_headlen(struct vmxnet3_adapter *adapter, struct sk_buff *skb)
+{
+	if (adapter->is_shm)
+		return VMXNET3_SHM_SKB_GETLEN(skb);
+	else
+		return compat_skb_headlen(skb);
+
+}
+
+static inline void
+vmxnet3_skb_put(struct vmxnet3_adapter *adapter, struct sk_buff *skb, unsigned int len)
+{
+	if (!adapter->is_shm) {
+		skb_put(skb, len);
+	} else {
+		unsigned int oldlen = VMXNET3_SHM_SKB_GETLEN(skb);
+		VMXNET3_SHM_SKB_SETLEN(skb, len + oldlen);
+	}
+}
+
+static inline struct sk_buff*
+vmxnet3_dev_alloc_skb(struct vmxnet3_adapter *adapter, unsigned long length)
+{
+	if (adapter->is_shm) {
+		int idx;
+		struct sk_buff* skb;
+		idx = vmxnet3_shm_alloc_page(adapter->shm);
+		if (idx == SHM_INVALID_IDX)
+			return NULL;
+
+
+		/* The length is arbitrary because that memory shouldn't be used */
+		skb = dev_alloc_skb(100);
+		if (skb == NULL) {
+			vmxnet3_shm_free_page(adapter->shm, idx);
+			return NULL;
+		}
+
+		VMXNET3_SHM_SKB_SETIDX(skb, idx);
+		VMXNET3_SHM_SKB_SETLEN(skb, 0);
+
+		return skb;
+	} else {
+		return dev_alloc_skb(length);
+	}
+}
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_map_* --
+ *
+ *      Covers for pci_map_*. Deal with the shared memory version of skbs.
+ *
+ * Results:
+ *      DMA address
+ *
+ * Side effects:
+ *      None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+static inline dma_addr_t
+vmxnet3_map_single(struct vmxnet3_adapter *adapter,
+		struct sk_buff * skb,
+		size_t offset,
+		size_t len,
+		int direction)
+{
+	if (adapter->is_shm) {
+		unsigned long shm_idx = VMXNET3_SHM_SKB_GETIDX(skb);
+		struct page *real_page = VMXNET3_SHM_IDX2PAGE(adapter->shm, shm_idx);
+		return pci_map_page(adapter->pdev,
+				real_page,
+				offset,
+				len,
+				direction);
+	} else {
+		return pci_map_single(adapter->pdev,
+				skb->data + offset,
+				len,
+				direction);
+	}
+
+}
+
+static inline dma_addr_t
+vmxnet3_map_page(struct vmxnet3_adapter *adapter,
+		struct page *page,
+		size_t offset,
+		size_t len,
+		int direction)
+{
+	if (adapter->is_shm) {
+		unsigned long shm_idx = (unsigned long)page;
+		page = VMXNET3_SHM_IDX2PAGE(adapter->shm, shm_idx);
+	}
+
+	return pci_map_page(adapter->pdev,
+			page,
+			offset,
+			len,
+			direction);
+}
+
+/*
+ *-----------------------------------------------------------------------------
+ *
+ * vmxnet3_(put|alloc)_page --
+ *
+ *      Allocation and release of pages. Either use regular or shared memory
+ *      pages.
+ *
+ * Results:
+ *      Depends
+ *
+ * Side effects:
+ *      None.
+ *
+ *-----------------------------------------------------------------------------
+ */
+static inline void
+vmxnet3_put_page(struct vmxnet3_adapter *adapter,
+		struct page *page)
+{
+	if (!adapter->is_shm)
+		put_page(page);
+	else
+		vmxnet3_shm_free_page(adapter->shm, (unsigned long)page);
+}
+
+static inline void *
+vmxnet3_alloc_page(struct vmxnet3_adapter *adapter)
+{
+	if (adapter->is_shm)
+		return (void*) (unsigned long) vmxnet3_shm_alloc_page(adapter->shm);
+	else
+		return alloc_page(GFP_ATOMIC);
+
+}
+
+
+#endif
diff -w -N -r -u open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/vmxnet3_shm_shared.h open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/vmxnet3_shm_shared.h
--- open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/vmxnet3_shm_shared.h	1970-01-01 01:00:00.000000000 +0100
+++ open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/vmxnet3_shm_shared.h	2009-12-17 22:26:31.000000000 +0100
@@ -0,0 +1,94 @@
+/*********************************************************
+ * Copyright (C) 2009 VMware, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation version 2 and no later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ *
+ *********************************************************/
+
+/*
+ * vmxnet3_shm_shared.h --
+ *
+ *   Header shared between vmxnet3 shared memory kernel driver and userspace.
+ *
+ */
+
+#ifndef __VMXNET_SHARED_SHM
+#define __VMXNET_SHARED_SHM
+
+#include <linux/ioctl.h>
+
+// ioctl constants
+#define SHM_IOCTL_MAGIC 'v'
+#define SHM_IOCTL_TX                  _IO(SHM_IOCTL_MAGIC, 0)
+#define SHM_IOCTL_ALLOC_ONE           _IO(SHM_IOCTL_MAGIC, 1)
+#define SHM_IOCTL_ALLOC_MANY          _IO(SHM_IOCTL_MAGIC, 2)
+#define SHM_IOCTL_ALLOC_ONE_AND_MANY  _IO(SHM_IOCTL_MAGIC, 3)
+#define SHM_IOCTL_FREE_ONE            _IO(SHM_IOCTL_MAGIC, 4)
+
+/*
+ * invalid index
+ *
+ * Must be 0 so that a invalid shared memory page has the same
+ * value as a NULL struct page. We need that because we overload
+ * the same field for regular and shared memory version of vmxnet3.
+ */
+#define SHM_INVALID_IDX 0
+
+// sizes of shared memory regions in pages
+#define SHM_DATA_START 0
+#define SHM_DEFAULT_DATA_SIZE 4096
+#define SHM_MAX_DATA_SIZE 16384
+#define SHM_CTL_START 16384
+#define SHM_CTL_SIZE 1
+
+// ring size (in entries) is limited by the single control page - 4 bytes per re
+#define SHM_RX_RING_SIZE 500
+#define SHM_TX_RING_SIZE 500
+
+// maximum fragments per packet is 16 (64k) + 2 for metadata
+#define VMXNET3_SHM_MAX_FRAGS 18
+
+// shared memory ring entry
+struct vmxnet3_shm_ringentry
+{
+   uint16_t idx;      // index of this page in the pool
+   uint16_t len: 13;  // length of data in this page
+   uint16_t own: 1;   // whether the receiver owns the re
+   uint16_t eop: 1;   // end of packet
+   uint16_t trash: 1; // ignore all the data in this packet, but still take ownership
+};
+
+static const struct vmxnet3_shm_ringentry RE_ZERO = {0,0,0,0,0};
+
+// shared memory control page
+struct vmxnet3_shm_ctl
+{
+   struct vmxnet3_shm_ringentry rx_ring[SHM_RX_RING_SIZE];
+   struct vmxnet3_shm_ringentry tx_ring[SHM_TX_RING_SIZE];
+
+   // XXX move kernel_* into the kernel, currently here for debugging
+   // user_rxi is used by poll() to avoid going to sleep when there are packets waiting
+   uint16_t user_rxi, user_txi;
+   uint16_t kernel_rxi, kernel_txi;
+
+   struct
+   {
+      uint64_t user_rx, user_tx;
+      uint64_t kernel_rx, kernel_tx;
+   } stats;
+
+   uint64_t channelBad;
+};
+
+#endif
diff -w -N -r -u open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/vmxnet3_version.h open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/vmxnet3_version.h
--- open-vm-tools-2010.01.19-226760/modules/linux/vmxnet3/vmxnet3_version.h	1970-01-01 01:00:00.000000000 +0100
+++ open-vm-tools-2009.12.16-217847/modules/linux/vmxnet3/vmxnet3_version.h	2009-12-17 22:26:31.000000000 +0100
@@ -0,0 +1,35 @@
+/*********************************************************
+ * Copyright (C) 2007 VMware, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation version 2 and no later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ *
+ *********************************************************/
+
+/*
+ * vmxnet3_version.h --
+ *
+ * Version definitions for the Linux vmxnet3 driver.
+ */
+
+#ifndef _VMXNET3_VERSION_H_
+#define _VMXNET3_VERSION_H_
+
+#define VMXNET3_DRIVER_VERSION          1.0.5.0
+#define VMXNET3_DRIVER_VERSION_COMMAS   1,0,5,0
+#define VMXNET3_DRIVER_VERSION_STRING   "1.0.5.0"
+
+/* a 32-bit int, each byte encode a verion number in VMXNET3_DRIVER_VERSION */
+#define VMXNET3_DRIVER_VERSION_NUM      0x01000500
+
+#endif /* _VMXNET3_VERSION_H_ */
